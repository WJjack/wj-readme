class100集合框架

## 集合框架

数组 ： 类型确定 长度固定 int[] nums = {};

集合 ： 默认Object类型 长度可以自由增长

### 架构

Collection\ 单列集合 最高级父接口

 List 子接口 有序集合（有序：展示顺序与保存顺序一致）==》排序

 特点：有索引 可以存储重复值 可以使用普通for循环、增强for循环（迭代器）

 ArrayList LinkedList Vector

 Set 子接口 无序集合（无序：展示顺序与保存顺序不一定一致）==》去重

 特点：无索引 不可以存储重复值 只能使用增强for循环（迭代器）

 HashSet TreeSet

 LinkedHashSet

### Collection\ 单列集合父接口

boolean add(E) 添加元素

boolean remove(E) 移除元素

boolean removeIf(Predicate) 有条件删除某些元素

 参数为一个接口 要实现其中的test() 返回true则当前元素被删除 返回false被保留

void clear() 清除所有元素

boolean isEmpty() 判断是否有元素

boolean contains(E) 判断某个元素是否存在 根据hashCode() equals()

int size() 返回元素个数

boolean addAll(Collection) 存入一个小集合

boolean removeAll(Collection) 从大集合中 移除参数集合中所有的元素

boolean containsAll(Collection) 从大集合中 判断是否包含小集合中的所有元素

Iterator iterator() 获取当前集合的正向迭代器 增强for循环的前身

Object数组类型 toArray() 转数组

数组类型 toArray(数组) 转数组

```
        //必须准备引用数据类型的数组        Integer[] nums = new Integer[cc.size()];        cc.toArray(nums);        System.out.println(Arrays.toString(nums));        Object[] array = cc.toArray();        //int[] n = (int[])array; //不能直接强转数组类型        int[] n = new int[array.length];        //需要通过循环 每个元素 单独强转        for(int i =0;i<array.length;i++) {            n[i] = (int)array[i];        }        //数组转集合  要求 数组必须是引用数据类型        Double[] dd = new Double[] {3.5,7.8,3.14,8.9};        List<Double> asList = Arrays.asList(dd);        for(double d:asList) {            System.out.print(d+" ");        }
```

#### 练习

创建Pet宠物类 String name int age

创建ArrayList集合循环存储五个宠物对象

输入宠物昵称 判断是否存在 存在则将年龄+2

输入宠物昵称和年龄 构成一个宠物对象 判断集合中是否存在相同属性值的对象

输入宠物昵称 判断是否存在 存在则删除这个宠物对象（提示 隐藏方法）

通过迭代器展示所有宠物信息

将该集合转为数组 展示

一个Object集合 删除所有int类型的元素

删除User集合中所有年龄>20岁的人

```
ArrayList<User> au = new ArrayList<User>();au.removeIf(new PreImpl());//removeIf方法会循环将每一个元素 传入接口实现类中的test()进行判断//单独创建一个类 实现 Predicate接口中的test()  返回true会被删除 否则被保留public class PreImpl implements Predicate<User>{    public boolean test(User u){        return u.getAge()>20;    }}//使用局部内部类技术 将接口外部实现类 优化掉Predicate<User> pu = new Predicate<User>(){      public boolean test(User u){        return u.getAge()>20;    }};au.removeIf(pu);//因为Predicate接口是一个函数式接口（只有唯一一个【抽象方法】的接口）   @FunctionalInterface//可以使用lambda表达式 再一次优化Predicate<User> pu = (User u)->{ return u.getAge()>20; };au.removeIf(pu);Predicate<User> pu = u->u.getAge()>20 ;au.removeIf(pu);
```

### 泛型

当不确定类型时 使用泛型占位

泛型的赋值 必须使用引用数据类型 （包装类）

#### 自定义泛型

在类中定义泛型 整个类都可以使用

```
public class Pet<E,F>{    E name;    F age;    public E getName(){        return name;    }}    //测试类中    Pet<String,Integer> p = new Pet<String,Integer>();    p.name = "豆豆";    p.age = 1;    syso(p.getName())    //豆豆
```

在方法中定义泛型 只能在方法中使用

```
    public <E> void get(E e){        syso(e);    }    public void get(Object o){        syso(o);    }    //测试类    对象.get(18); //参数可以为任意类型
```

在接口中定义泛型

```
public interface Work<K,V>{ //接口中定义泛型 一般就是用在抽象方法的设计上    public K getKey();    public void getValue(V v);}
```

 1.可以在实现类中为泛型赋值

```
pubic class Pets implements Work<String,Double>{    public String getKey(){        return "";    }    public void getValue(double v){        syso(v);    }}
```

 2.可以继续使用实现类提供的泛型

```
public class Pets<E,F,G> implements Work<E,F>{    public E getKey(){    }    public void getValue(F v){    }}    //测试类    Pets<Integer,Boolean,Integer> p = new Pets<Integer,Boolean,Integer>();    sso(p.getKey());//一定返回Integer类型数据    p.getValue(true);//参数必须是boolean类型数据
```

？泛型占位符

当在代码的中间环节 还不确定泛型类型时 可以使用？

泛型受限（泛型边界） 控制将来泛型类型的取值范围

```
public class Demo1{}public class Demo2<E> extends Demo1{}public class Demo3 extends Demo2{}public class Impl {    //Collection<Demo1> cd1 = new ArrayList<Demo1>();    //cd1.add(new Demo1());    //cd1.add(new Demo2());    //cd1.add(new Demo3());    public void show1(Collection<Demo1> c) {  //只能传入 Collection<Demo1>                                    //集合中的元素 可以是 Demo1对象 Demo2对象 Demo3对象    }    //泛型受限  边界    public void show2(Collection<? extends Demo2> c) {            //可以传入 Collection<Demo2>   demo2  demo3            //Collection<Demo3>   Demo3对象    }    public void show3(Collection<? super Demo2> c) {            //可以传入 Collection<Demo2>    Collection<Demo1>    }    public void show4(Collection<? super Demo2<?>> c) {        //可以传入 Collection<Demo2<?>>    Collection<Demo1>    }    public void show5(Collection<? super Demo2<String>> c) {        //可以传入 Collection<Demo2<String>>    Collection<Demo1>    }}        //测试类1        Impl impl = new Impl();        Collection cd = new ArrayList();        Collection<Demo1> cd1 = new ArrayList<Demo1>();        cd1.add(new Demo1());        cd1.add(new Demo2());        impl.show1(cd1);//不能放入Demo2 Demo3集合        Collection<Demo2> cd2 = new ArrayList<Demo2>();//        cd2.add(new Demo1());//        cd2.add(new Demo2());//        cd2.add(new Demo3());//        impl.show1(cd2);        Collection<Demo3> cd3 = new ArrayList<Demo3>();        impl.show2(cd2);//可以放入 cd2 cd3        impl.show3(cd2);//可以放入 cd2 cd1    //测试类2        Impl impl = new Impl();        //准备的实参 必须要符合形参样式        Collection<Demo2<?>> c2 = new ArrayList<Demo2<?>>();        //Demo2的泛型 在每一个Demo2的对象中确认        c1.add(new Demo2<String>());        c1.add(new Demo2<Integer>());        impl.show4(c2);        //准备的实参 选择了Demo1        Collection<Demo1> c1 = new ArrayList<Demo1>();        impl.show4(c1);        impl.show4(c5);//报错        Collection<Demo2<String>> c5 = new ArrayList<Demo2<String>>();        impl.show5(c5);        impl.show5(c1);
```

### ArrayList\

底层是一个数组模型 默认长度为10

```
private static final int DEFAULT_CAPACITY = 10;    //默认数组长度private static final Object[] EMPTY_ELEMENTDATA = {}; //当声明时定义长度为0  则使用该数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};//默认10长度空参构造transient Object[] elementData;        //真正使用的数组private int size;    //集合元素个数private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    //可以存储的最大元素数量    //空参构造    public ArrayList() {          this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    }    //带int类型参数的构造 定义数组默认长度    public ArrayList(int initialCapacity) {        if (initialCapacity > 0) {            this.elementData = new Object[initialCapacity];        } else if (initialCapacity == 0) {            this.elementData = EMPTY_ELEMENTDATA;        } else {            throw new IllegalArgumentException("Illegal Capacity: "+                                               initialCapacity);        }    }    //带单列集合实参的构造方法 可以将其他形式的单列集合 转为ArrayList集合    public ArrayList(Collection<? extends E> c) {        elementData = c.toArray();        if ((size = elementData.length) != 0) {            // c.toArray might (incorrectly) not return Object[] (see 6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        } else {            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        }    }    //当空间不足时 添加元素会执行扩容方法 每次默认扩容为原来的1.5倍    private void grow(int minCapacity) {        // overflow-conscious code        int oldCapacity = elementData.length;        int newCapacity = oldCapacity + (oldCapacity >> 1);        if (newCapacity - minCapacity < 0)            newCapacity = minCapacity;        if (newCapacity - MAX_ARRAY_SIZE > 0)            newCapacity = hugeCapacity(minCapacity);        // minCapacity is usually close to size, so this is a win:        elementData = Arrays.copyOf(elementData, newCapacity);    }
```

优点：数组模型 元素是连续的 可以直接通过下标获取某个元素 ===》查询快

缺点：1.每次扩容 老数组成垃圾数据

 2.新增 删除 都需要元素移动 ===》增删慢

### 常用方法

void add(int index, E element) index>=0 index<=size()

boolean addAll(int index, Collection<? extends E> c)

E remove(int index) 返回被删除的元素

E set(int index, E element) 使用第二个参数 替换第一个参数下标位的元素 返回被替换的老元素

E get(int index)

int indexOf(Object o) 根据元素对象的hashCode() equals()判断 找不到 返回 -1

ListIterator listIterator() //双向迭代器 默认从头号元素开始迭代

ListIterator listIterator(int index) 从某个下标位开始迭代 应该存放起始下标+1

### 迭代器Iterator\

每个单列集合都有自己的迭代器 泛型就是集合元素的类型

boolean hasNext() 判断有没有下一个元素

E next() 获取下一个元素 并且模拟指针下跳

void remove() 删除当前元素

```
        //正向迭代器        //每一个集合 都有一个自己的迭代器对象        Iterator<String> it = as.iterator();        while(it.hasNext()) {            //有没有下一个元素 返回boolean            String name = it.next();    //获取下一个元素 同时模拟指针下跳    //获取下一个元素            //System.out.println(name);            if(name.equals("李四") || name.equals("马六")) {                //as.remove(name);    //不能一边迭代 一边用集合删除元素 会报并发异常                //ConcurrentModificationException                it.remove();        //迭代器自身的删除方法            }        }
```

#### 子类 双向迭代器 ListIterator\

ListIterator\ 集合对象.listIterator()

ListIterator\ 集合对象.listIterator(int startIndex)

只能用于有序集合

boolean hasNext() 判断有没有下一个元素

E next() 获取下一个元素 并且模拟指针下跳

boolean hasPrevious() 判断有没有上一个元素

E previous() 获取上一个元素

void remove() 删除当前元素

```
        ArrayList<Integer> ai = new ArrayList<Integer>();        ai.add(56);        ai.add(77);        ai.add(26);        ai.add(78);        ai.add(15);        ai.add(16);        ListIterator<Integer> lit = ai.listIterator(ai.size());        while(lit.hasPrevious()) {            int num = lit.previous();            System.out.print(num+" ");        }
```

### LinkedList\

双链结构===》查询慢 增删快

```
//在LinkedList内 有一个内部类 表示每一个节点对象    private static class Node<E> {        E item;            //当前节点的值        Node<E> next;    //保存该节点下一个节点对象        Node<E> prev;    //保存该节点上一个节点对象        Node(Node<E> prev, E element, Node<E> next) {            this.item = element;            this.next = next;            this.prev = prev;        }    }    //空参构造    public LinkedList() {    }    //带参构造    public LinkedList(Collection<? extends E> c) {        this();        addAll(c);    }
```

### 常用方法

void addFirst(E e)

void addLast(E e)

E getFirst()

E getLast()

E removeFirst()

E removeLast()

### Vector

线程安全 效率低 JDK1.0

可以使用Iterator ListIterator 也可以使用独有的一套迭代器

```
        Vector<Integer> vi = new Vector<Integer>();        vi.add(123);        vi.add(666);        vi.add(35);        vi.add(123);        vi.add(789);        vi.add(123);        Enumeration<Integer> e = vi.elements();        while(e.hasMoreElements()) {            Integer num = e.nextElement();            System.out.print(num+" ");        }
```

### 比较器 接口

#### 案例

每个元素都是字母 的String类型的集合 希望升序排列 再 【降序排列】

优先根据姓名的升序 姓名相同 根据年龄的降序 给用户添加排序的选项 【1. 2.年龄升序 姓名降序】

#### 内部比较器

Comparable\ compareTo(E o)

要比较的实体类直接实现

```
public class User implements Comparable<User>{    private String name;    int ae;    double score;    public User(String name, int ae,double score) {        super();        this.name = name;        this.ae = ae;        this.score = score;    }    public String getName(){        return name;    }    @Override    public String toString() {        return "User [name=" + name + ", ae=" + ae + "]";    }    @Override    public int compareTo(User o) {        // TODO Auto-generated method stub        //年龄升序        //return this.ae-o.ae;        //姓名降序        //return o.name.compareTo(this.name);        //.姓名升序 姓名相同 年龄升序 //        if(this.name.equals(o.name)) {//            return this.ae - o.ae;//        }//        return this.name.compareTo(o.name);        //年龄降序 年龄相同 姓名升序        if(this.ae == o.ae) {            return this.name.compareTo(o.name);        }        return o.ae-this.ae;        //根据积分的升序        return this.score>o.score?1:-1;    }}    //测试类中        ArrayList<User> au = new ArrayList<User>();        au.add(new User("jdfg",18));        au.add(new User("kert",21));        au.add(new User("zw",18));        au.add(new User("jdfg",22));        au.add(new User("jdfg",18));        au.add(new User("jdywrfg",18));        au.add(new User("jdfg",19));        Collections.sort(au);    //如果元素所属类没有实现比较器 则该行代码报错        for(User u : au) {            System.out.println(u);        }
```

#### 外部比较器

Comparator\ compare(E o1,E o2)

单独创建一个类来实现

1.外部比较器可以有多个 随意选择

2.不影响实体类结构

3.外部比较器优先级更高 可以覆盖内部比较器

```
    //外部比较器1public class Ucom1 implements Comparator<User> {    //姓名升序    @Override    public int compare(User o1, User o2) {        // TODO Auto-generated method stub        return o1.name.compareTo(o2.name);    }}    //外部比较器2public class Ucom2 implements Comparator<User> {    //年龄降序    @Override    public int compare(User o1, User o2) {        // TODO Auto-generated method stub        return o2.ae-o1.ae;    }}    //外部比较器3public class Ucom3 implements Comparator<User> {    //姓名升序 姓名相同 年龄升序    @Override    public int compare(User o1, User o2) {        // TODO Auto-generated method stub        if(o1.name.equals(o2.name)) {            return o1.ae-o2.ae;        }        return o1.name.compareTo(o2.name);    }}    //外部比较器4public class Ucom4 implements Comparator<User> {    //年龄降序 年龄相同 姓名升序    @Override    public int compare(User o1, User o2) {        // TODO Auto-generated method stub        if(o1.ae==o2.ae) {            return o1.name.compareTo(o2.name);        }        return o2.ae-o1.ae;    }}        //测试类中        ArrayList<User> au = new ArrayList<User>();        au.add(new User("jdfg",18));        au.add(new User("kert",21));        au.add(new User("zw",18));        au.add(new User("jdfg",22));        au.add(new User("jdfg",18));        au.add(new User("jdywrfg",18));        au.add(new User("jdfg",19));        System.out.println("1.姓名升序 2.年龄降序 3.姓名升序 姓名相同 年龄升序 4.年龄降序 年龄相同 姓名升序");        int sel = new Scanner(System.in).nextInt();        if(sel==1) {            Collections.sort(au, new Ucom1());        }else if(sel==2) {            Collections.sort(au, new Ucom2());        }else if(sel==3) {            Collections.sort(au, new Ucom3());        }else {            Collections.sort(au, new Ucom4());        }        for(User u : au) {            System.out.println(u);        }        //局部内部类 优化掉 接口实现类对象 并使用lambda表达式 优化函数式接口        Collections.sort(au,(o1,O2)-> o1.ae-o2.ae);        au.sort((o1,o2)->o1.age);        int[] nums = {5,3,8,9,1,6,4};        Arrays.sort(nums);        Arrays.sort(nums,(n1,n2)->n2-n1);//降序        User[] us = new User[au.size()];        au.toArray(us);        Arrays.sort(us,(o1,o2)-> o1.age==o2.age? o2.score>o1.score?1:-1 : o1.age-o2.age);
```

#### 案例

int类型的集合 升序排列 降序排列

String 类型的集合 默认是升序排列 如何降序排列呢

User类 全英文name属性 double类型的成绩

存入几个用户对象 按照以下要求排序展示

1.姓名升序 2.成绩降序 3.姓名升序 姓名相同 成绩升序 4.成绩降序 成绩相同 姓名升序

### 内部类

一个类的内部又存放了另一个类结构 称为内部类结构

特点：内部类和外部类可以互相访问其所有资源

 内部类 必须依靠外部类对象创建

 一般将此理论用于快速实现接口

#### 案例

class School

 String schoolName

 String time

 class Classes 成员内部类

 String classesName

 int num

 show() 学校信息 班级信息

 show(ArrayList\) 学校信息 班级信息

 addTeachar()

 class Teacher 局部内部类

 String name int age

 show() 学校信息 班级信息 老师信息



#### 成员内部类

直接在一个类的内部 编写另一个类

想要获取成员内部类的对象 必须先创建外部类对象

#### 局部内部类

在外部类的某个方法中 编写一个类结构

```
public class School {    private String name;//学校名称    String time;        //建校时间    //Classes c;    //ArrayList<Classes> ac;    public School(String name, String time) {        super();        this.name = name;        this.time = time;    }    //成员内部类    public class Classes {        private String name;//班级名称        int num;            //班级人数        public Classes(String name, int num) {            super();            this.name = name;            this.num = num;        }        public void show() {            //可以调用外部类的私有资源            System.out.println("学校名称："+School.this.name+" 建校时间："+time+" 班级名称："+this.name+" 班级人数："+this.num);        }    }    public void show(ArrayList<Classes> acs) {        System.out.println("学校名称："+this.name+" 建校时间："+this.time);        System.out.println("班级信息");        Iterator<Classes> it = acs.iterator();        while(it.hasNext()) {            Classes c = it.next();            c.show();            //可以调用内部类的私有资源            //System.out.println(c.name);        }    }    public void addTeacher(Classes cc,String name,int a) {        int money = 10;        //局部内部类所在的方法中的局部变量 如果与当前局部内部类的某个变量重名 则无法调用        //如果局部内部类使用了所在方法的某个变量 则该变量必须是常量 可以省略final        //money+=10000;        class Teacher{            private String name;//老师姓名            int age;            //老师年龄            //int money = 100;            public Teacher(String name, int age) {                super();                this.name = name;                this.age = age;            }            public void show(Classes c) {                System.out.println("学校信息");                System.out.println("学校名称："+School.this.name+" 建校时间："+time);                System.out.println("班级信息");                //Classes c = new Classes("",77);//直接创建班级                System.out.println("班级名称："+c.name+" 班级人数："+c.num);                System.out.println("老师信息");                System.out.println("老师姓名："+this.name+" 老师年龄："+this.age);                //money += 10000;                System.out.println(money);            }        }        //局部内部类的使用 必须依赖于所在的方法        Teacher t = new Teacher(name,a);        t.show(cc);    }}    //测试类        School ss = new School("蜗牛大学","9999-9-9");        //内部类的对象 必须先有外部类对象        Classes c = ss.new Classes("开发1班",123);        c.show();//内部类的show方法 可以访问到外部类的私有属性        System.out.println();        ArrayList<Classes> ac = new ArrayList<Classes>();        ac.add(c);        ac.add(ss.new Classes("开发2班",55));        ac.add(ss.new Classes("开发3班",22));        ac.add(ss.new Classes("开发4班",25));        ac.add(ss.new Classes("开发5班",27));        ss.show(ac);        System.out.println();        System.out.println("老师信息展示");        ss.addTeacher(ac.get(4), "王老师", 33);
```

#### 使用局部内部类 优化接口的实现

```
    public interface Test{        public void show();    }    //测试类中        //看似new的接口 ==》通过局部内部类 1.编写接口实现类 2.并同时创建实现类的对象    Test t = new Test(){        public void show(){            syso("方法实现过程");        }    };        t.show();    new Test(){        public void show(){            syso("");        }    }.show();    //实现类 并获取其匿名对象 直接调用实现的方法
```

Lambda表达式

只能用于函数式接口（只有一个【唯一】的【抽象方法】的接口 ） 挂上 [@FunctionalInterface](https://github.com/FunctionalInterface) 不报错

(形参参数列表)->{方法实现过程 方法体}

```
    Test t = ()->{syso("方法实现过程");};    Test t = ()->syso("方法实现过程");    //比较器的lambda写法    Comparator<String> c = new Comparator<String>(){        public int compare(String o1,String o2){            return o1.compareTo(o2);        }    }    Comparator<String> c = (o1,o2)-> o1.compareTo(o2);
```

### Stream 数据流式操作

Stream\ 单列集合.stream()

Stream\ Stream.of(引用数据类型数组名)

Stream\ Arrays.stream(可以放基本数据类型的数组)

#### 常用方法

interface Predicate\ boolean test(E o)

interface Comparator\ int compare(E o1,Eo2)

interface Comparable\ int compareTo(E o)

interface Consumer\ void accept(E o)

interface Function\ T apply(E o)

filter(interface Predicate\) 添加过滤信息 获取筛查后的集合流 o->o.getName.equals(“bbb”)

sorted() 对于流中的元素 采用对象的内部比较器进行排序

sorted(interface Comparator\) 对于流中元素进行排序

foreach(interface Consumer\) foreach(o->syso(o));

long count() 统计流中有几行数据

map([Function](eclipse-javadoc:☂=Class87_9/F:\/workSoft\/java\/JDK1.8.0_74_x64\/jre\/lib\/rt.jar;☂java.util.function.Function)<? super [Worker](eclipse-javadoc:☂=Class87_9/F:\/workSoft\/java\/JDK1.8.0_74_x64\/jre\/lib\/rt.jar;☂com.woniuxy.homework.Worker), ? extends [String](eclipse-javadoc:☂=Class87_9/F:\/workSoft\/java\/JDK1.8.0_74_x64\/jre\/lib\/rt.jar;☂java.lang.String)> mapper) map( o->o.getName()).filter(o->o.equals(“张三”))

 提出元素中的某个属性 成为新的数列 类型也将变为属性的类型

limit(long) 获取当前流的前几行

skip(long) 跨过流的前几行

boolean anyMatch(interface Predicate\) 是否有元素匹配条件

boolean allMatch(interface Predicate\) 是否所有元素都匹配条件

distinct() 去除流中的重复元素

List\ .collect(Collectors.toList()) 将流信息转为集合

```
ArrayList<User> au = new ArrayList<User>();au.add(new User());...//原始集合经过处理后获得的数据 可以继续通过.collect(Collectors.toList())转为List集合List<User> lu = au.stream().filter()...   .collect(Collectors.toList());//再使用集合构造方法 转为子实现类集合ArrayList<User>  auu = new ArrayList\<User>(lu);
```

#### 练习

//男生张xx的个数

//获取所有两字姓名的人数

//输出展示所有薪资在3000-10000的员工信息

//输出展示所有男生信息 并按薪资降序排列

//输出展示所有女生信息 且 年龄为18到20岁之间 按id降序 （要求使用两个filter分别筛查性别和年龄）

//获取所有元素的姓名 并展示

//获取所有元素的薪资 并按降序排列 展示前三名 请展示工资最高的三名用户的工资

//获取所有元素的年龄 并按降序排列 从第三名开始展示

//判断是否有元素符合 年龄大于30这个要求

//判断所有元素年龄 是否都大于20岁

```
public class Worker{    //。。。    int id;    String name;    int age;    int money;    char gender;    //构造方法    //toString()}public class Param {    public static ArrayList<Worker> aw = new ArrayList<Worker>();    static{        aw.add(new Worker(1,"张三",18,5000,'男'));        aw.add(new Worker(2,"李四",20,8000,'女'));        aw.add(new Worker(3,"张五",28,4000,'男'));        aw.add(new Worker(4,"张三五",21,8000,'女'));        aw.add(new Worker(5,"马六",30,9000,'男'));        aw.add(new Worker(6,"张物流",20,14000,'男'));        aw.add(new Worker(7,"李司棋",16,10000,'女'));        aw.add(new Worker(8,"赵洋洋",18,4000,'女'));        aw.add(new Worker(9,"王富贵",18,7000,'女'));        aw.add(new Worker(10,"张七七",28,6000,'男'));        //。。。多存一些对象    }}
```

#### 无序集合 Set(子接口)

展示顺序与存储顺序 未必一致 但是一定是一个固定的顺序（根据地址计算出的顺序）

不能存储重复数据 不能使用普通for循环

#### 案例

为什么int类型的无序集合可以自动去重

因为int的包装类中重写了hashCode()和equals()方法

#### 总结

java中是根据hashCode()和equals()共同作用 实现去重的

```java
        
String str1 = new String("重地");        
String str2 = new String("通话");        
System.out.println(str1.hashCode());    //1179395        
System.out.println(str2.hashCode());    //1179395
```

基本数据类型、String 默认去重==>如果要保存相同的字符串 则可以使用String增强类

自定义类型集合 如果没有重写hashCode()和equals() 那么直接判断地址是否相同

 如果重写了 则判断重写的方法中所判断的属性

#### LinkedHashSet

 是HashSet的子类 多了一根链条 记录了保存顺序 ==》展示顺序就是存储顺序

```
//User类重写了hashCode() equals() 只判断姓名        //该集合会根据姓名去重 展示顺序与存储顺序一致        LinkedHashSet<User> lhu = new LinkedHashSet<User>();        lhu.add(new User("张三",18));        lhu.add(new User("jsdfg",18));        lhu.add(new User("jsdfg",28));        lhu.add(new User("jsdfg",19));        lhu.add(new User("张三",19));        //只存储了 第一个 第二个 对象        User u = new User("李四",22);//根据李四 算出 哈希值 842092        lhu.add(u);        u.name = "王豆豆";        syso(u.hashCode());//当前u的hash值 变为29574570        lhu.add(u);    //可以存入 因为已经存入的李四 虽然姓名变成“王豆豆” 但是hash值不会改变        lhu.stream().forEach(o->System.out.println(o));        //最后会有两个王豆豆        HashSet<StringBuilder> sb = new HashSet<StringBuilder>();        sb.add(new StringBuilder("aaa"));        sb.add(new StringBuilder("aaa"));        sb.add(new StringBuilder("aaa"));        sb.add(new StringBuilder("aaa"));        保存了四个元素        HashSet<String> ss = new HashSet<String>();        ss.add(new String("aaa"));        ss.add(new String("aaa"));        ss.add(new String("aaa"));        ss.add(new String("aaa"));        只保存了一个值
```

### TreeSet

存储数据的过程必须依赖于比较器 ==》根据比较器返回值实现去重

返回0则认为是重复数据 返回其他任何数据都认为是不重复数据

基本数据类型、String 因为已经实现了Comparable接口 则可以通过该比较器去重

自定义类型 一定要给与其比较器 否则存储对象报错 根据比较器结果决定是否重复

注意：1.使用TreeSet存储的元素类型 必须有比较器 否则存储失败

 2.比较器返回0 统统认为是重复数据 返回1 都被认定为不重复 返回-1不仅不重复且逆向保存

```
public class User implements Comparable<User>{    String name;    int age;    public User(String name, int age) {        super();        this.name = name;        this.age = age;    }    @Override    public String toString() {        return "User [name=" + name + ", age=" + age + "]";    }    @Override    public int compareTo(User o) {        // TODO Auto-generated method stub        //return this.name.equals(o.name)?0:1;        if(this.name.equals(o.name)) {            return o.age-this.age;        }        return this.name.compareTo(o.name);    }}    //测试类中           TreeSet<User> hu = new TreeSet<User>();        hu.add(new User("bbb",18));        hu.add(new User("bbb",23));        hu.add(new User("aaa",28));        hu.add(new User("bbb",20));        hu.add(new User("ccc",18));        hu.add(new User("aaa",28));        hu.add(new User("bbb",19));        hu.add(new User("aaa",21));        hu.add(new User("aaa",25));        hu.add(new User("bbb",22));        hu.add(new User("aaa",28));        hu.stream().forEach(o->System.out.println(o));        TreeSet<String> ts = new TreeSet<String>((o1,o2)->1);        ts.add(new String("aaa");        ts.add("aaa");        ts.add(new String("aaa"));        ts.add("aaa");        保存四个元素
```

#### 案例

保存五个5==》编写外部比较器 放入构造方法 可以覆盖内部比较器

```
        TreeSet<Integer> ti = new TreeSet<Integer>((o1,o2)->-1);        ti.add(5);        ti.add(5);        ti.add(5);        ti.add(5);        ti.add(5);        System.out.println(ti);    //[5,5,5,5,5]
```

### 双列集合Map

#### HashMap

每一组数据 由 键和值 组成 ===》键值对

键不能重复 可以为null 只能有一个null键

值可以重复 可以为null 可以有多个null值

当存入重复键的键值对时 执行的是覆盖操作

#### 常用方法

int size() 键值对数量

put(k,v) 添加一组键值对 如果添加了重复键的键值对 则执行的是替换操作

v get(k) 通过键找值

v remove(k) 直接删除 返回值 删除键值对

boolean remove(k,v) 先判断 再删除

v replace(k,newV) 直接替换旧值 返回旧值

boolean replace(k,oldV,newV) 先判断 再替换

Set\ keySet() 获取键的集合

Collection\ values() 获取值的集合

boolean containsKey(k) 判断是否包含某个键

boolean containsValue(V) 判断是否包含某个值

Set> entrySet() 获取Map集合的 所有键值对 所组成的映射关系集合

### Entry 映射关系类

K getKey() 获取当前映射关系中的键

V getValue() 获取当前映射关系中的值

void setValue(V) 给当前映射关系中的值重新赋值

#### 注意：

通过键的集合 删除某个键 会导致HashMap集合中该键值对被删除

通过Entry集合 修改或者删除某个键值对 也会导致HashMap集合中该键值对的修改或删除

#### 练习

class User

 int id String name double score

测试类中

 循环存储用户输入长度的键值对 以用户id为键 用户对象为值

 使用键的集合 、键值对集合 两种方案迭代展示元素

 查询某id用户是否存在 存在则展示其信息 并删除 不存在则输出提示

 查询某个用户是否存在 只要id name score全部相同 就认定存在重复

 输入姓名 删除该姓名用户键值对 要求使用键值对方案实现删除操作

 输入id 将该id对应的值替换为新的用户对象 要求在键值对方案中操作