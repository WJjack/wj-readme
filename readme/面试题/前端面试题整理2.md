# 面试题整理



# this指向问题

- 普通函数：
  - 没有直接调用者，this指向window，如果是严格模式，this指向undefined
  - 有调用者，this指向的就是调用对象
- 对象的方法：this指向的是该方法所属对象
- 构造函数：this指向的是实例对象
- 原型对象：this指向的是实例对象
- 绑定事件函数：this指向的是函数的调用者
- 箭头函数：this永远指向其上下文的this

## 改变this指向

call、apply、bind

### 区别

1. call、apply是立即改变,bind非立即改变
2. 参数
   - call: 函数.call(目标对象,参数1,参数2...)
   - apply:函数.apply(目标对象,[数组])
   - bind: 函数.bind(目标对象,参数1,参数2...)（）	  //返回值是一个函数
3. bind是绑定，执行需要再次调用



# 数据类型

在js中，数据类型分为简单数据类型和复杂数据类型

## 简单类型

string、number、boolean、null、undefined、Symbol

Symbol：ES6 引入的一种新的原始数据类型，用于表示独一无二的值

```
const sym1 = Symbol('adc');
const sym2 = Symbol('adc');
sym1 === sym2   //结果为false
```

## 复杂类型

array，object，function，Date，RegExp

## 判断数据类型

1. typeof

   ```
   let f = undefined;
   let g = null;
   let h = new Date();
   let i = /test/;
   
   console.log(typeof f);//undefined
   console.log(typeof g);//object
   console.log(typeof h);//object
   console.log(typeof i);//object
   ```

   缺点：无法判断null、日期、正则

2. instanceof

   检测对象数据类型（js中一切对象） 表示当左侧为右侧的实例时返回true

   ```
   let a="string";  //这里 a 和 b 为保存字符串和数字类型值的变量，不是他们的实例
   let b=111;
   
   console.log(a instanceof String);//false  //注意：instanceof 后对象类型的大小写
   console.log(b instanceof Number);//false
   console.log(c instanceof Object);//true
   console.log(d instanceof Array);//true
   console.log(e instanceof Function);//true
   console.log(h instanceof Date);//true
   console.log(i instanceof RegExp);//true
   
   let a=new String('string');  //这样通过new一个实例就为true了
   let b=new Number(111);
   console.log(a instanceof String);//true
   console.log(b instanceof Number);//true
   ```

   缺点：判断 字符串、数字 类型，需要new一个实例，才能判断准确

3. Object.prototype.toString.call()        用该方法判断最准确

   ```
   console.log(Object.prototype.toString.call(a) === '[object String]');//true
   console.log(Object.prototype.toString.call(b) === '[object Number]');//true
   console.log(Object.prototype.toString.call(c) === '[object Object]');//true
   console.log(Object.prototype.toString.call(d) === '[object Array]');//true
   console.log(Object.prototype.toString.call(e) === '[object Function]');//true
   console.log(Object.prototype.toString.call(f) === '[object Undefined]');//true
   console.log(Object.prototype.toString.call(g) === '[object Null]');//true
   console.log(Object.prototype.toString.call(h) === '[object Date]');//true
   console.log(Object.prototype.toString.call(i) === '[object RegExp]');//true
   ```

   

# 浅拷贝

浅拷贝是地址的引用

简单来说，即B赋值给A，A修改时，B也会发生变化

如果数据是一层，是深拷贝，但是如果数据嵌套了多层复杂数据类型，就是浅拷贝

# 深拷贝

在拷贝对象的时候，不仅要对当前进行所有内容的拷贝产生一个**新的对象**，还要对对象里面的引用类型数据进行**对象创建**

实现方法：

1. JSON先转字符串再转对象：
   let 新对象=JSON.parse(JSON.stringify(老对象));

   该方法缺点：无法拷贝undefined、function、正则

2. 递归

# 递归

特点：

1. 在运行过程中，函数自己调用自己
2. 递归函数必须要接收参数（比如：要递归谁？）
3. 至少应该有一个结束条件

例：从1加到100的和，用递归实现

```JS事件循环
// 1 + 2 + 3 + ... + 100
function sum(min, max) {
    if (min === max) {
        return min;
    }
    return min + sum(min + 1, max)
}

// return  1 + 2 + 3 + 4 + ... + 99 + 100

const result = sum(1, 3);
console.log(result);
```

# JS事件循环

## 异步任务类型

微任务的优先级高于宏任务

- 微任务：promise.then、nextTick
- 宏任务：setTimeout、setInterval

遇Promise直接执行

## 事件循环的过程

1. **主线程**先执行代码，分析全局变量，函数等内容
2. 先将全局变量放入全局上下文对象中，入栈放入栈底
3. 发现有函数调用，创建函数上下文对象，包括函数里面的内部变量和函数代码
4. **函数内部**执行Js库里的api，发现有同步代码就直接执行，有异步代码就放入异步队列中
5. **异步代码**放入异步队列后，内存专门开辟空间，浏览器会执行异步代码？
6. **主线程**执行完毕，就回去检测异步队列里是否还有异步任务，如果有，则等待完成，一旦完成，继续检测异步任务，这个过程是循环的持续进行，一旦异步队列任务执行完毕，那么整个程序也退出了。
7. 浏览器会给每个任务绑定一个事件
8. 主线程结束



# *Promise

一种异步编程的解决方案，**本身**是同步代码，then方法是异步**获取结果**

有三种状态：

- `pending`(进行中)
- `resolved`(已完成)
- `reject`(已失败)

当`Promise`的状态由`pendeing`转变为`resolved`或`reject`时，会执行相应的方法

**特点**：只有**异步操作**的结果，可以决定当前是哪一种状态，任务其他操作都无法改变这个状态；同时，状态一旦改变，就无法再次改变状态

promise**解决**的：

- 回调地狱，代码难以维护
- `promise`可以支持多个并发的请求，获取并发请求中的数据

## Promise常用方法

- `Promise.resolve(value)`：类方法，该方法返回一个以 value 值解析后的 Promise 对象
- `Promise.reject`：类方法，且与 resolve 唯一的不同是，返回的 promise 对象的状态为 rejected
- `Promise.all`：作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调
- `Promise.race`：作用也是接收一组异步任务，然后并行执行异步任务，只保留第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃
- `Promise.prototype.catch()`：发生错误时的回调函数
- `Promise.prototype.then()`：为 Promise 实例添加状态改变时的回调函数
- `Promise.prototype.finally()`：不管 Promise 对象最后状态如何，都会执行的操作 （ES8引入）

# *Echarts图表自适应

在图表数据初始化函数之后，调用echarts对象的**resize()**函数

```
window.onresize = function () {
  	echarts.resize()
}
```

# *AntD改变主题色

`config-overrides.js`文件中，修改`"@primary-color"`属性为自己需要的颜色

# *vuex和redux的区别

1. vuex有modules，模块化
2. vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer
3. vuex无需订阅重新渲染函数，只要生成新的state，就能自动重新渲染数据

# *前端工程化

含义：使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化

主要目的：为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间

## 如何实现

**模块化**、**组件化**、**规范化**、**自动化**

1. 模块化

   - JS模块化

   - css模块化

   - 资源模块化

     优点：**依赖关系单一化**、**资源处理集成化**、**项目结构清晰化**

2. 组件化

   从UI拆分下来的**每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元**，称之为**组件**

3. 规范化

   - 目录结构的制定
   - 编码规范
   - 前后端接口规范

4. 自动化：任何简单机械的重复劳动都应该让机器去完成

   - 图标合并
   - 持续集成
   - 自动化构建
   - 自动化部署
   - 自动化测试

# 地址栏输入url敲回车后发生了什么

1. **DNS查询**

   DNS:域名系统  --  Internet上解决网上机器命名的一种系统

2. **建立连接**：客户端与服务器通过**三次握手**建立连接

   三次握手

   - 第一次握手：浏览器向服务器发起询问：是否处于正常工作状态？		浏览器发送请求到服务器
   - 第二次握手：服务器告诉浏览器：一切正常，你可以向我发送请求        服务器接收到请求，然后处理请求，最终响应给浏览器

   - 第三次握手，浏览器告诉服务器：了解，准备发送请求            浏览器解析并且渲染服务器响应数据

3. **发送请求**

4. **接收响应**

5. **渲染页面**

6. **断开连接**：通过**四次挥手**断开连接

   四次挥手

   - 第一次挥手：浏览器向服务器发起询问：可否断开连接?
   - 第二次挥手：服务器：确认数据是否响应完毕
   - 第三次挥手：服务器：数据已响应完毕，可以断开连接
   - 第四次挥手：浏览器：断开连接

# Web 缓存

数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存

**浏览器缓存**：HTTP 缓存、indexDB、cookie、Web Storage、WebSql、Application Cache、PWA

# http缓存

http缓存：当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源

- **强缓存**   状态码200

  强制缓存在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求

  这种方式页面的加载速度是最快的，性能也是很好的，但是在这期间，如果服务器端的资源修改了，页面上是拿不到的，因为它不会再向服务器发请求了

  - Expires：指缓存过期的时间，超过了这个时间点就代表资源过期
  - Cache-Control
  - Pragma

- **协商缓存**   状态码304

  当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期，或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行协商，与服务器端对比判断资源是否进行了修改更新

  - **Last-modified/If-Modified-Since**
  - **ETag/If-None-Match**

## 使用HTTP缓存

**在<head>标签中嵌入<meta>标签，这种方式只对页面有效，对页面上的资源无效**

```
<meta http-equiv="Cache-Control" content="max-age=7200" /> // 其他主流浏览器识别的标签

<meta http-equiv="Expires" content="Mon, 20 Aug 2018 23:00:00 GMT" />  // 仅有IE浏览器才识别的标签
```

浏览器**初次**请求：

![](C:\Users\dell\Desktop\简历\自己\新建文件夹\浏览器第一次请求.jpg)

浏览器**再次**请求：

![](C:\Users\dell\Desktop\简历\自己\新建文件夹\浏览器再次请求.jpg)



# TypeScript

TypeScript的设计目的是解决JavaScript的“痛点”：**弱类型**和**没有命名空间**，导致很难模块化，不适合开发大型程序

- **编译时的强类型**

  申明变量的类型，那么任何其他类型的赋值将会引起编译错误

- **模块化**

  利用TypeScript的关键词module，可以达到类似于命名空间的效果，而export可以控制是否被外部访问

# type和interface的区别

**相同**：都可以描述一个对象或者函数

**不同**：

1. type可以声明 基本类型，联合类型，**元组**（存储的元素数据类型不同） 的别名，interface不行
2. type 语句中可以使用 typeof 获取类型实例
3. type 支持类型映射，interface不支持
4. interface能够声明合并，type不能

# 泛型

宽泛的类型，通常用于类和函数

泛型的本质是参数化类型，通俗的将就是所操作的数据类型被指定为一个参数，这种参数类型可以用在**类**、**接口**和**方法**的创建中，分别成为**泛型类**、**泛型接口**、**泛型方法**

函数在定义时，若指定返回值不为**void**或者**any**，则 在函数 内 必须 写 **return**

TypeScript可以使用泛型来创建**可重用**的组件。支持当前数据类型，同时也能支持未来的数据类型。扩展灵活。可以在编译时发现你的类型错误，从而保证了类型安全

## 解决的问题

函数传入不确定类型参数，传入什么类型就返回什么类型

例：判断字符串、数组的最小值，定义了泛型，可直接return一个值，函数复用，而不用去写两个函数



# CSS

## 多余文本显示省略号

### 显示一行

```
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;	//设置不换行
```

### 显示指定行数

```
display: -webkit-box;	//将对象作为弹性盒模型显示
-webkit-box-orient: vertical;	//指定弹性盒子子元素的排列方式：从顶部向底部垂直布置子元素
-webkit-line-clamp: 3;	//限制在一个块元素显示的文本的行数
overflow: hidden;
```

## 盒子垂直居中

1. 使用flex布局

   ```
   //写在父盒子中：
   display:flex;
   justify-content:center;
   align-item:center;
   ```

2. position定位 + margin

3. position定位 + transform

   ```
   position:absolute;
   top:50%;
   left:50%;
   transform:translate(-50%, -50%);
   ```

4. table和table-cell

   ```
   //父元素设置
   display: table;	   //元素作为块级表格来显示
   
   //子元素设置
   display:table-cell;		//元素作为一个表格单元格显示
   vertical-align: middle;	 	//设置元素的垂直对齐方式
   ```

   

## 伪类和伪元素

### 伪类

用于当已有元素处于的某个状态时，为其添加对应的样式

- :link 应用于未被访问过的链接；   
- :hover 应用于鼠标悬停到的元素；
- :active 应用于被激活的元素；
- :visited 应用于被访问过的链接，与:link互斥。
- :focus 应用于拥有键盘输入焦点的元素

### 伪元素

用于创建一些不在文档树中的元素，并为其添加样式

- :first-child 选择某个元素的第一个子元素；  
- :last-child 选择某个元素的最后一个子元素；
- :nth-child() 选择某个元素的一个或多个特定的子元素；
- :only-child 选择的元素是它的父元素的唯一一个子元素
- :empty 选择的元素里面没有任何内容
- :checked匹配被选中的input元素，这个input元素包括radio和checkbox。
- :default匹配默认选中的元素，例如：提交按钮总是表单的默认按钮。
- :disabled匹配禁用的表单元素。
- :enabled匹配没有设置disabled属性的表单元素。
- :valid匹配条件验证正确的表单元素



## position属性

- absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

- fixed：生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

- relative：生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。

- static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

- inherit：规定应该从父元素继承 position 属性的值。

- sticky：粘性定位，该定位基于用户滚动的位置。

  它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;它会固定在目标位置。

  **注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。

  ```
  .sticy {	//页面往上滚动，到达顶部后固定在顶部，网页滚动回来后，又回到原本的位置
      position: sticky;
      position: -webkit-sticky;  //处理兼容
      top: 0;
      left: 0
  }
  ```

## CSS中的单位

- px：绝对单位，页面按精确像素展示

- em：相对单位，基准点为**父节点**字体的大小，如果自身定义了font-size，按自身来计算。一般浏览器字体大小默认为16px，则2em == 32px；
- rem：相对单位，可理解为”root em”, 相对于**html**的字体大小来计算，是CSS3新增属性
- vw：viewpoint width，视窗宽度，1vw=视窗宽度的1%
- vh：viewpoint height，视窗高度，1vh=视窗高度的1%
- vmin：vw和vh中较小的那个
- vmax：vw和vh中较大的那个
- %：百分比
- ex：依赖于英文字母小 x 的高度
- ch：数字 0 的宽度

## CSS 样式书写顺序及规范

### 书写顺序

1. 定位属性
2. 自身属性：width、height、padding、border、margin、background
3. 文字样式
4. 文本属性：text-align、line-height、letter-spacing
5. css3中新增属性：content、box-shadow、border-radius、transform(旋转、移动)

### 作用

减少浏览器reflow（回流），提升浏览器渲染dom的性能

## 实现三角形

1. 容器宽高设为0
2. 容器边框设为透明，需要设置边框宽度
3. 其中一条边框设置颜色、边框宽度（与容器边框宽度相同）

```
div{
        width: 0;
        height: 0;
        border: 200px transparent solid;
        border-left: blue 200px solid;
      }
```

## 盒模型

它具有： content（不包含 padding 和 border），padding，border，margin 四个**属性**，这就是盒子模型

盒模型有两种**形式**：

- 标准盒模型：`box-sizing:content-box;`   默认值，代表W3C盒模型
- 怪异盒模型：`box-sizing:border-box;`  代表IE盒模型

两种模式的**区别**：

　　标准模式会被设置的padding撑开，而怪异模式则相当于将盒子的大小固定好，再将内容装入盒子。盒子的大小并不会被padding所影响。

## flex弹性布局

Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性

- 任何一个容器都可以指定为 Flex 布局

- 行内元素也可以使用 Flex 布局

  ```
  .box{
    display: inline-flex;
  }
  ```

- Webkit 内核的浏览器，必须加上`-webkit`前缀

  ```
  .box{
    display: -webkit-flex; /* Safari */
    display: flex;
  }
  ```

设为 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效

### Flex 容器的属性

- flex-direction：决定主轴的方向

  - `row`（默认值）：主轴为水平方向，起点在左端。
  - `row-reverse`：主轴为水平方向，起点在右端。
  - `column`：主轴为垂直方向，起点在上沿。
  - `column-reverse`：主轴为垂直方向，起点在下沿

- flex-wrap：设置是否换行

- flex-flow：`flex-direction`属性和`flex-wrap`属性的简写形式

  默认值为`row nowrap`

- justify-content：定义了Flex项目在主轴上的对齐方式

  - `flex-start`（默认值）：左对齐
  - `flex-end`：右对齐
  - `center`： 居中
  - `space-between`：两端对齐，项目之间的间隔都相等。
  - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍
  - `space-evenly`:每个弹性项目之间的距离相同，包含第一个和最后一个与弹性容器的距离

- align-items：定义了Flex项目在侧轴上的对齐方式

  - stretch：默认值。元素被拉伸以适应容器
  - center：元素位于容器的中心
  - flex-start：元素位于容器的开头
  - flex-end：元素位于容器的末尾
  - baseline：元素位于容器的基线上

- align-content：定义了多根轴线的对齐方式

  如果项目只有一根轴线，该属性不起作用



## 清除浮动的方法

1. 父元素添加伪元素选择器可以动态添加一个子元素，完成清除浮动的操作

   ```
    .clearfix::after{
        content:"";
        display:block;
        clear:both;
        height:0;
        visibility:hidden;	 //规定元素是否可见，与display的区别在于，只是视觉上消失，在文档中的占位还在
    }
   ```

2. 父元素添加`overflow:hidden`

   原理：将父元素变成一个BFC容器，容器里面的元素如何排列不会影响到容器外面的元素

3. 通过`<br clear="all">`将浮动元素和非浮动元素分隔开

   缺点：不符合工作中结构、样式、行为三者分离的要求

4. 用`inline-block`清除浮动：`display:inline-block`

   缺点：margin左右auto居中失效

##  解决浮动引起的高度塌陷

当不给父元素设置宽高时，父元素的宽高会被子元素的内容撑开。但是当子元素设置浮动属性后，子元素会溢出到父元素外，父元素的宽高也不会被撑开了，称之为“高度塌陷”

**解决**

1. 给父元素设置：`overflow: hidden`
2. 使用 after 伪元素：在末尾添加一个看不见的块元素来清除浮动



## display、visibility、opacity区别

### 1、空间占据

- `display: none;` 是彻底消失，不在文档流中占位，浏览器也不会解析该元素
- `visibility:hidden;` 是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素
- `opacity：0`等同于`visibility:hidden` 

### 2、子元素继承

- `display:none`不会被子元素继承
- `visibility:hidden`会被子元素继承，可以通过设置子元素`visibility:visible`使子元素显示出来
- `opacity：0` 会被子元素继承，但不能通过设置子元素`opacity: 1`使父元素重新显示

### 3、事件绑定

- `display:none`因为元素都不存在页面上，故也无法触发它上面绑定的事件
- `visibility:hidden`元素上绑定的事件也无法触发
- `opacity: 0`元素上绑定的事件可以触发

### 4、过渡动画

- `display:none`和`visibility:hidden`无效
- `opacity: 0`有效

## rgba()和opacity

两者都能实现透明效果

- opacity作用于元素，以及元素内的所有内容的透明度（子元素会继承）
- rgba()只作用于元素的颜色或其背景色（子元素不会继承）

## 重绘与回流

重绘：当页面中的节点样式发生改变时，浏览器会对当前页面进行重绘

回流：当页面中布局发生改变时，浏览器会对当前页面进行回流

回流一定会发生重绘，但重绘不一定会发生回流

### 如何减少和避免回流

1. 样式集中改变：添加一个类，样式都在类中改变
2. 使用absolute脱离文档流
3. 使用 display:none ，不使用 visibility，也不要改变 它的 z-index
4. 能用css3实现的就用css3实现

## src与href

- src：source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置

  在请求src资源时会将其指向的资源下载并应用到文档内，例如**js脚本**、**img图片**和**frame**等元素

- href：Hypertext Reference（超文本引用）的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接

##  link 和@import

两者都是外部引用CSS的方式，但是存在一定的区别：

1. 能加载的东西不同：

   link是XHTML标签，除了加载CSS外，还可以定义RSS(Really Simple Syndication:真正简易联合)等其他事务；@import属于CSS范畴，只能加载CSS

2. 加载时间不同：

   link引用CSS时，在页面载入时同时加载；@import需要页面完全载入以后加载

3. 浏览器兼容问题：

   link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持

4. 是否支持js操作改变样式：

   link支持使用Javascript控制DOM去改变样式；而@import不支持

## mask-size

设置蒙版绘画区域上蒙版图像的大小



# *HTML

## *各大浏览器特点

开源：开放源代码

- IE：Trident内核，兼容性好，非开源

- firefox：Geckos内核，个性化定制插件，开源
- opera：Presto内核，渲染速度快，开源
- chrome：Webkit内核，速度最快，开源
- Safari：Webkit内核，开源

### 解决浏览器兼容

**CSS 兼容前缀**

- IE：-ms-
- firefox：-moz-
- opera：-o-
- chrome：-webkit-



## 语义化标签

```
<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。
<nav>：标记导航，仅对文档中重要的链接群使用。
<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。
<article>：定义外部的内容，其中的内容独立于文档的其余部分。
<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。
<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。
<footer>：页脚，只有当父级是body时，才是整个页面的页脚。
<audio>
<video>
```

### 什么是语义化标签

根据内容的语义化，选择合适的标签，便于开发者阅读和写出更优雅的代码

### 使用语义化标签好处

- 语义化标签具有可读性，使得文档结构清晰
- 浏览器便于读取，有利于SEO优化
- 展现在页面中时，用户体验好
- 便于团队开发和维护

## HTML5浏览器端存储

- localStorage：生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。

  存放数据大小一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

- sessionStorage：仅在当前会话下有效，关闭页面或浏览器后被清除。

  存放数据大小一般为5MB,它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

- cookie：生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

   存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。

  与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好

## Doctype

是document type(文档类型)的简写，用来说明你用的XHTML或者HTML是什么版本

### 作用

Doctype声明位于文档的最前面，处于标签之前。**目的**是告知浏览器的解析器，用什么文档类型**规范**来解析这个文档。Doctype声明也是用于区分html和html5的方法之一。

### 严格模式与混杂模式

- 严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码
- 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码

**如何区分**

浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD（文档类型定义） 直接相关

1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。**（严格 DTD ——严格模式）** 
2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。**（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）** 
3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。**（DTD不存在或者格式不正确——混杂模式）**
4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大地实现了向后兼容。**（ HTML5 没有严格和混杂之分）**

**意义**

严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响。如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。

## html5新特性

1. 语义化标签

2. 增强型表单

   - 多个新的表单 Input 输入类型，如：color,url,date等

   - 新增表单属性:

     placehoder 属性、required 属性、min 和 max 属性(设置元素最小值与最大值)、pattern 属性(正则表达式验证<input> 元素的值)、autofocus 属性(页面加载时，域自动获得焦点)、multiple 属性(规定<input> 元素中可选择多个值)

3. 新增视频 <video> 和音频 <audio> 标签

4. Canvas绘图

5. SVG绘图

6. 地理定位

7. Web Storage：sessionStorage 和localStorage

8. WebSocket：是一个持久化的协议，相对于HTTP这种非持久的协议来说

9. 拖放：把 draggable 属性设为 true

   `<img draggable="true">`

## 页面加载优化

1. 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器

2. 用innerHTML代替DOM操作，**减少DOM操作次数**，优化javascript性能

3. 当需要设置的样式很多时设置类名而不是直接操作内联style

4. 少用全局变量、缓存DOM节点查找的结果，减少IO读取操作(IO流：I：就是input ；O：就是output ，故称：输入输出流)

5. 避免使用CSS Expression（css表达式)

   css表达式：**在css属性后使用expression()连接一段JavaScript表达式**

   ```
   background-color: expression((new Date()).getHours()%2?"#FFFFFF": "#000000" );
   ```

   这里的CSS属性可以是元素固有的属性，也可以是自定义属性

6. 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢

7. 代码优化：

   - 避免使用for…in（它能枚举到原型，所以很慢）
   - 在JS中倒序循环会略微提升性能
   - 减少迭代的次数
   - 基于循环的迭代比基于函数的迭代快8倍
   - 用Map表代替大量的if-else和switch会提升性能

## CDN

### 概述

CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的**CACHE(缓存)层**，将网站的内容发布到最接近用户的网络”**边缘**“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度

### 优化原理

CDN网络是在用户和服务器之间增加Cache层，主要是通过接管DNS实现,将用户的请求引导到Cache上获得源服务器的数据

## 防抖和节流

- 防抖：高频率触发的事件,在指定的单位时间内，只响应**最后一次**，如果在指定的时间触发，则重新计算时间(后面触发的事件执行，替代了前面的事件)
- 节流：高频率触发的事件,在指定的单位时间内，只响应**第一次**(前面触发的执行前，忽略后面的事件)

**使用场景**

防抖（debounce）
1.search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
2.window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

节流（throttle）
1.鼠标不断点击触发，mousedown(单位时间内只触发一次)
2.下拉加载更多（无限滚动）事件，用throttle(节流函数)来判断

## 对SPA的理解

SPA（ single-page application：单页面应用 ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以**不能使用浏览器的前进后退功能**，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上有着天然的弱势。

## 瀑布流

瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。

**如何判断浏览器是否触底**

document.body.clientHeigth + document.body.scrollTop===document.body.scrollHeight



# *JS

## *正则表达式

**修饰符**

- g：执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）
- i：执行对大小写不敏感的匹配
- m：执行多行匹配

**元字符**

- \d：查找数字
- \s：查找空白字符

**表达式**

- [xx] ：查找方括号之间的任何字符
- [0-9] ：查找任何从 0 至 9 的数字
- (x|y) ：查找任何以 | 分隔的选项

## *ES6新特性

ES：ECMAScript是javascript标准

ES6就是ECMAScript的第6个版本

- **let const**
- **模板字符串**
- **解构**
- **函数传参可以有默认值**
- **rest参数**  （可变参数)
- **箭头函数**
- **for of**
- **class类**
- **导入导出**
  - 导入improt
  - 导出export default
- **promise**、**generator**
- **Symbol数据类型**
- **Set集合**
- **map**、**filter**、**forEach**

## *for of 和for in区别

1. for in是遍历键名，for of是遍历键值
2. `for...of`不能循环普通对象，需要和`Object.keys()`搭配使用
3. 最好在循环**对象属性**的时候使用`for...in`,在遍历**数组**的时候的时候使用`for...of`

## *map和forEach

**相同**

每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组）

**不同**

- forEach没有返回值
- map会分配内存空间存储新数组并返回

## *set和map区别

**set**

- Set 本身是一种构造函数，用来生成 Set 数据结构，类似于数组

- 键值与键名是一致
- 不能通过迭代器来改变set的值，因为set的值就是键

**map**

- 本质上是键值对的集合，类似集合
- map的键是不能修改，但其键对应的值可以修改

## *promise和async/await区别

1. promise是ES6的内容，async/await属于ES7

2. async/await是基于Promise实现的，它不能用于普通的回调函数

3. async/await使异步代码看起来像同步代码，解决回调地狱问题的代码更加的清晰

4. promise的错误可以通过catch来捕捉（建议尾部捕获错误）；

   async/await既可以用.then，又可以用try-catch捕捉

5. async/await无法完全替代promise，不同网络请求无法同时发起

## 原生JS中获取DOM元素的方法

- 通过ID获取（getElementById）
- 通过name属性（getElementsByName）
- 通过标签名（getElementsByTagName）
- 通过类名（getElementsByClassName）
- 通过选择器获取一个元素（querySelector）
- 通过选择器获取一组元素（querySelectorAll）
- 获取html的方法（document.documentElement）
- 获取body的方法（document.body）



## 纯函数

1. 一个函数的返回结果只依赖于它的参数
2. 在执行过程中没有副作用
   - 副作用：一个函数执行过程产生了外部可观察的变化（修改了全局变量或修改传入的参数）

同时满足以上两个，就是纯函数

## generator函数

**定义**：Generator函数是ES6提供的一种异步编程解决方案，形式上也是一个普通函数

在Javascript中，一个函数一旦开始执行，就会运行到最后或遇到return时结束，运行期间不会有其它代码能够打断它，也不能从外部再传入值到函数内部

而Generator函数（生成器）的出现使得打破函数的完整运行成为了可能，其语法行为与传统函数完全不同

**特征**

- function关键字与函数名之间有一个星号 "*" （推荐紧挨着function关键字）
- 函数内使用 yield 表达式，定义不同的内部状态 （可以有多个yield）
- 直接调用 Generator函数并不会执行，也不会返回运行结果，而是返回一个遍历器对象（Iterator Object）
- 依次调用遍历器对象的next方法，遍历 Generator函数内部的每一个状态

## 箭头函数与普通函数区别

1. **外形不同**

   箭头函数使用箭头定义，普通函数中没有

2. **匿名函数**

   普通函数可以有匿名函数，也有具体命名的函数；但箭头函数都是匿名函数

3. **构造函数**

   - 箭头函数不能用于构造函数，不能使用new
   - 普通函数可以用于构造函数，以此创建对象实例

4. **this指向**

   - 普通函数中，this总是指向调用它的对象，如果用作构造函数，this指向创建的对象实例
   - 箭头函数本身没有this，但它在声明时可以捕获其所在上下文的this供自己使用

## class类

在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。它可以被看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法

语法有两个组成部分：类表达式和类声明

### 类声明

- 定义一个类的一种方法是使用一个类声明，即用带有class关键字的类名
- 函数名和实例化构造名相同且大写（非强制）
- 函数声明和类声明之间的一个重要区别是函数声明会提升，类声明不会。需要先进行声明，再去访问，否则会报错
- 类声明不可以重复
- 类必须使用 new 调用，否则会报错

### 类表达式

类表达式可以是被命名的或匿名的

### 类的方法

- **constructor 方法**
- **静态方法**：可以通过类名调用，不能通过实例对象调用
- **原型方法**
  - 类的所有方法都定义在类的 prototype 属性上面，在类的实例上面调用方法，其实就是调用原型上的方法
  - 原型方法可以通过实例对象调用，但不能通过类名调用
- **实例方法**：实例方法也可以通过实例对象调用，但同样不能通过类名调用



## js实现继承的方式

### 1、原型链继承

将父类的实例作为子类的原型

```
function Cat(){ }
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';
 
var cat = new Cat();
console.log(cat.name);
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
```

缺点：

1. 来自原型对象的所有属性被所有实例共享
2. 创建子类实例时，无法向父类的构造函数传参

### 2、原型式继承（Object.create）

```
const person = {
    name: 'star',
    colors: ['red', 'blue'],
}

const person1 = Object.create(person);
const person2= Object.create(person);

person1.name = 'litterstar';
person2.name = 'luckystar';

person1.colors.push('yellow');

console.log(person1.colors); // [ 'red', 'blue', 'yellow' ]
console.log(person2.colors); // [ 'red', 'blue', 'yellow' ]
```

缺点：来自原型对象的所有属性被所有实例共享（person1修改 colors 会影响person2的 colors，这点跟原型链继承一样）

### 3、构造继承（经典继承）

在子类的构造函数中使用 call()或者 apply() 调用父类型构造函数

```
function Parent(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'yellow'];
}
Parent.prototype.getName = function() {
    console.log(this.name)
}

function Child(name, age) {
    // 核心代码：“借调”父类型的构造函数
    Parent.call(this, name);
    this.age = age;
}

let child1 = new Child('litterStar');
let child2 = new Child('luckyStar');
console.log(child1.name); // litterStar
console.log(child2.name); // luckyStar

// 这种方式只是实现部分的继承，如果父类的原型还有方法和属性，子类拿不到这些方法和属性
child1.getName(); // TypeError: child1.getName is not a function
```

缺点：

1. 实例并不是父类的实例，只是子类的实例
2. 只能继承父类的实例属性和方法，不能继承原型属性/方法
3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

### 4、组合继承（最常用）

原型链 + 借用构造函数

缺点：调用了两次父类构造函数，生成了两份实例

### 5、class继承(ES6中的继承)

```
class Parent {}
class Child extends Parent {
    constructor(name, age, color) {
        // 调用父类的constructor(name, age)
        super(name, age);
        this.color = color;
    }
    toString() {
        return this.color + ' ' + super.toString(); // 调用父类的toString()
    }
}
```

### 6、寄生组合式继承（最理想）

```
function Parent(name) {
    this.name = name;
    this.colors = ['red', 'blue', 'yellow'];
}
Parent.prototype.getName = function() {
    console.log(this.name)
}

function Child(name, age) {
    Parent.call(this, name);  // 核心代码①
    this.age = age;
}
// 核心代码②
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```



## 作用域和作用域链

- 规定变量和函数的可使用范围称作**作用域**
- 每个函数都有一个作用域链，查找变量或者函数时，需要从局部作用域到全局作用域依次查找，这些作用域称为**作用域链**

### 常见作用域

变量的作用域是在定义时决定而不是执行时决定，叫做**静态作用域**

- 全局作用域：变量在函数或者代码块{ }外定义

- 函数作用域（局部作用域）：在函数内部定义的变量

  - 函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域
  - 如果想读取函数内的变量，必须借助 return 或者闭包

- 块状作用域

  如，if后的{ }

- 动态作用域：只能在执行阶段才能决定变量的作用域



## 原型和原型链

### 原型

1. 每个对象都默认拥有一个_proto_属性，该属性对象有一个constructor属性指向构造该对象的函数
2. 每个函数都默认拥有一个prototype属性，该属性对象有一个constructor属性指向构造该对象的函数
3. **每一个函数都有一个默认的属性：prototype, 称之为“原型”（显示原型），它本身也是一个对象，该对象拥有constructor属性，指向该函数**
5. **每个对象都默认拥有proto属性（隐式原型），它指向构造该对象的函数原型**
   ![](D:\new class\useful\原型闭环图.jpg)

```
在函数中，Function.proto === Function.prototype
```

### 原型链

作用：定义对象访问属性的顺序

多个`_proto_`向上查找组成的集合称为**原型链**

```
实例对象拥有__proto__原型属性，而该属性也是一个对象，既然是对象，也拥有__proto__属性，沿着链子指向上一级原型，直到终点(Object的原型:该原型没有__proto__)
```

- 所有实例`__proto__`都指向他们构造函数的`prototype`
- 所有的`prototype`都是对象，它的`_porto_`指向的是`Object()`的`prototype`
- 所有的构造函数的隐式原型指向的都是`Function()`的显示原型
- Object的隐式原型是null

### 原型链出口

返回null



## 闭包

定义在一个函数内部的函数，其中一个内部函数在包含他们的外部之外被调用时，就会形成闭包

### 特点

- 函数嵌套函数
- 函数内部可以引用外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

### 应用场景

- 函数节流，防抖
- 构造函数的私有属性
- Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调

### 优点

- 变量长期驻扎在内存中；
- 避免全局污染
- 能够读取函数内部的变量

### 缺点

- Js中常见的内存泄漏
- 意外的全局变量
- 被遗忘的计时器或回调函数
- 脱离DOM的引用



## 事件委托

定义：在父元素上绑定事件，利用事件的冒泡机制将子元素的事件冒泡到父元素去触发

Js事件主要分为两类：冒泡和捕获

w3c在制定规范的时候，将两种方式都保留下来，老版本的IE支持冒泡，现代浏览器，两种方式都支持

**事件委托**（事件代理）：元素没有绑定事件并不代表它没有这个事件，需要注册监听器去监听动作

利用了冒泡的特点，将本应该注册到子元素身上的事件，现在注册到了父元素上，在点击子元素的时候，通过冒泡机制将点击事件冒泡到父元素，在父元素上进行事件监听

**优势**：

- 减少了DOM的操作。（性能优化的核心）
- 减少了函数定义，优化了内存空间（每一个函数其实都是一个对象，函数多了内存消耗也大）
- 随时都可以添加子元素，添加的子元素有相应的事件响应

## 跨域

当一个请求url的**协议、域名、端口**三者之间任意一个与当前页面url不同即为跨域

它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响

### 如何实现

- JSONP

- CORS

- webpack本地代理

  在webpack.config.js中利用 WebpackDevServer 配置本地代理

- websocket

## *JSONP的原理

一种跨域通信的手段

1. 利用script标签的src属性来实现跨域。
2. 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。
3. 由于使用script标签的src属性，因此只支持get方法



# Vue

## 生命周期

4大阶段，共8个钩子函数

- 阶段1：创建阶段 (初始化data、methods等)

  ```
  创建前：beforeCreate(){}
  
  创建后:  created(){}
  ```

- 阶段2：挂载阶段 （dom渲染）

  ```
  挂载前  beforeMount(){}
  
  挂载后   mounted(){}
  ```

- 更新阶段 (更改数据--人为操作)

  ```
  更新前  beforeUpdate(){}
  
  更新后  updated(){}
  ```

- 销毁阶段 (销毁数据--人为操作) 

  ```
  销毁前 beforeDestroy(){}
  
  销毁后 destroyed(){}
  ```

  销毁的是当前组件中所有的功能，页面上已经渲染之后的数据还在

  默认只会销毁最后一个

### 父子组件执行顺序

- 加载渲染过程

  父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

### 发送异步请求

可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data已经创建，可以将服务器端返回的数据进行赋值

### 实现原理

Vue 的生命周期钩子核心实现是利用**发布订阅模式**，先把用户传入的生命周期钩子订阅好（内部采用数组的方法存储），然后在创建组件实例的过程中，会依次执行对应的钩子方法（发布）



## vue 内置指令

- v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。
- v-cloak - 这个指令保持在元素上直到关联实例结束编译 -- 解决初始化慢到页面闪动的最佳实践。
- v-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。
- v-on - 用于监听DOM事件。例如 v-on:click v-on:keyup
- v-html - 赋值就是变量的innerHTML -- 注意防止xss攻击
- v-text - 更新元素的textContent
- v-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。
- v-if / v-else / v-else-if。可以配合template使用；在render函数里面就是三元表达式。
- v-show - 使用指令来实现 -- 最终会通过display来进行显示隐藏
- v-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，不要使用index作为key。
- v-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度。



## Vue改变复杂类型数据不会响应的解决

在两种情况下修改 数据，Vue 不会触发视图更新：

1、在实例创建之后添加新的属性到实例上（给响应式对象新增属性）
 2、直接更改数组下标来修改数组的值

若data中数据类型较为复杂，方法methods中改变对象的属性，页面并不会改变

解决方法：

```
this.$set(对象,属性，值)	  //没有该属性，则是直接添加
this.$set(数组,下标,值)
```

原理：vue监听不到复杂类型数据的属性，使用this.$set()来进行强制更新，进而解决问题



## computed和watch区别

### 计算属性computed

1. 支持**缓存**，只有依赖数据发生变化时，才会重新进行计算函数；
2. 计算属性内不支持**异步**操作；
3. 计算属性的函数中都有一个`get`(默认具有，获取计算属性)和`set`(手动添加，设置计算属性)方法；
4. 计算属性是自动监听依赖值的变化，从而动态返回内容。

### 监听属性watch

1. 不支持缓存，只要数据发生变化，就会执行监听函数；
2. 侦听属性内支持异步操作；
3. 侦听属性的值可以是一个对象，接收`handler`回调，`deep`(深度监听)，`immediate`(立即监听)三个属性；
4. 监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。

### commputed缓存原理

`commputed`本质是一个惰性观察者；当计算数据存在于`data`或者`props`会警告

- 其缓存机制本质是通过一个dirty属性控制的，只有dirty为true时才会重新计算结果替换缓存
- dirty只有当其响应式数据发送变化时才会设置为true，重新计算后会再次被设置为false

Vue初次运行会对`commputed`属性进行初始化处理，初始化的时候会对每一个`cmmputed`属性`watcher`包装起来，这里会生成一个`dirty`属性值为`true`，然后执行



## Vue组件通信

1、props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。

2、$parent 和 $children 获取当前组件的父组件和当前组件的子组件。

3、$refs 获取组件实例。

4、envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。

5、vuex 状态管理。

## $route和$router

- `$route`是"路由信息对象"，包括`path`、`params`、`hash`、`query`、`mathched`、`name`等路由信息参数
- `$router`是"路由实例对象"，包括路由的跳转方法，钩子函数(导航守卫钩子函数)等

## Vue页面跳转传参

1. 使用`<router-link>`标签实现跳转

   ```
   语法：?参数名=值
   <router-link to="/stu/stu_add?id=1">添加学生</router-link></div>
   接收：{{this.$route.query.id}}
   ```

2.  通过js的方式：`this.$router.push`

   ```
   <button @click="add">添加学生</button>
   
   add(){
               this.$router.push('/stu/stu_add?id=100')
               this.$router.push(`/posts_detail?id=${this.post_id}`)	   //动态传参,不再有单引号
           }
   接收：{{this.$route.query.id}}
   ```

3. 改变路由配置

   ```
   path: '/stu/:参数名1/参数名2...',
   props:true
   
   接参：
   export default {
       props:['参数名1','参数名2'...], }
   ```

## keep-alive

`keep-alive`是Vue中一个内置组件。

特点：

- 被`keep-alive`包含的组件会保持状态（被缓存），当组件在切换时不会被销毁，可以避免组件的重复渲染
- 被`keep-alive`包裹的组件会新增两个生命周期函数：
  - `activeted`：当 keep-alive 包含的组件再次渲染的时候触发
  - `deactiveted`：当 keep-alive 包含的组件销毁的时候触发

- 常用的两个属性 include/exclude，允许组件有条件的进行缓存

## v-model原理

`v-model`本质就是一个语法糖，可以看成是`value`+`input`方法的语法糖，是vue的双向绑定指令；

- `model`层通过`defineProperty`来劫持每个属性，一旦监听到变化，则通过相关的页面元素更新；
- 通过编译模板文件 ，为控件的`v-model`绑定`input`事件，从而页面输入能实时更新相关`data`属性值

可以通过`model`属性的`prop`和`event`属性来进行自定义；原生的`v-model`会根据标签的不同生成不同的事件和属性。

`v-model`在内部为不同的输入元素使用不同的属性并抛出不同的事件：

1. `text`和`textarea`元素使用`value`属性和`input`事件
2. `checkbox`和`radio`使用`checked`属性和`change`事件；
3. `select`字段将`value`作为`prop`并将`change`作为事件；

## v-if 和 v-show

- v-if 在编译过程中会被转化成三元表达式，条件不满足时不渲染此节点。
- v-show 会被编译成指令，条件不满足时控制样式将此节点隐藏（display:none）

**使用场景**

- v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景。
- v-show 适用于需要非常频繁切换条件的场景。



## Vue双向绑定原理/Vue响应式原理

响应式原理：**在改变数据的时候，视图会跟着更新**



**vue采用 数据劫持 结合 观察者模式，通过`Object.defineProperty()`来劫持data中各个属性的setter、getterr，也就是reactive化，然后再new 一个自己的Watcher对象，Watcher 对象会被存放到订阅者 Dep 的 subs 中，数据被更新的时候，调用Dep函数里面 `notifyAll`方法来通知所有的watch进行工作**



书面解答：vue采用 **数据劫持** 结合 **观察者模式**，通过`Object.defineProperty()`来劫持data中各个属性的setter、getter（对应`Object.defineProperty()`中的get()与set()）,在数据变动时，发布消息给订阅者，触发响应的监听回调

**简单理解**：数据劫持→依赖收集→发布订阅模式

1、Object.defineProperty 数据劫持
 2、使用 getter 收集依赖 ，setter 通知 watcher派发更新。
 3、watcher 发布订阅模式

通俗理解：

1. 组件初始化的时候，先给每一个Data属性都注册getter，setter，也就是reactive化。然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里
2. 当data属性发生改变之后，就会遍历sub里所有的watcher对象，通知它们去重新渲染组件

### Object.defineProperty()

这个方法就是在一个对象上定义一个新的属性，或者改变一个对象现有的属性，并且返回这个对象

这个对象提供了get和set两个方法，可以劫持到属性发生的变化

Vue中对data里面的所有数据都做劫持，只要对data里面的内容进行修改，一定会进入`Object.defineProperty`函数里面去执行业务。

将Data中的数据进行get、set的劫持，这一步可以称为Reactive化 

### 观察者模式

是一种设计模式，设计模式就是把平时约定俗成的一些代码封装起来，以供使用

分为  **注册环节** 和  **发布环节**

所谓的依赖，其实就是**Watcher**   （**在getter中收集依赖，在setter中触发依赖**）

- 注册环节：**依赖收集**，**将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中**
- 发布环节：一旦执行`Object.defineProperty`的set方法，调用Dep函数里面 `notifyAll`方法来通知所有的watch进行工作。检测数据变化也更新页面



## vue 中的设计模式

1、工厂模式 - 传入参数即可创建实例
 虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode。

2、单例模式 - 整个程序有且仅有一个实例
 vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉。

3、发布-订阅模式。（vue 事件机制）

4、观察者模式。（响应式数据原理）

5、装饰器模式（@装饰器的用法）

6、策略模式，策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现方案 - 比如选项的合并策略

## Vue 性能优化

- 对象层级不要过深，否则性能就会差
- 不需要响应式的数据不要放在 data 中（可以使用 Object.freeze() 冻结数据）
- v-if 和 v-show 区分使用场景，computed 和 watch 区分场景使用
- v-for 遍历必须加 key，key值保证唯一，且避免同时使用 v-if
- 大数据列表和表格性能优化 - 虚拟列表 / 虚拟表格
- 防止内部泄露，组件销毁后把全局变量和时间销毁
- **图片懒加载、路由懒加载**
- 异步路由
- 第三方插件的按需加载
- 适当采用 keep-alive 缓存组件
- 防抖、节流的运用
- 服务端渲染 SSR or 预渲染



## 渲染时机

- 在`created`请求时，是在页面渲染出来之前做的事情，如果数据过大，可能造成页面**白屏**过久，因为`created`还没有dom元素生成，并且也不能操作dom元素。
- 在`mounted`请求时，是在页面渲染出来之后做的事情，此时可以操作dom元素

## Vuex

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）

- `state`(初始化数据)
- `actions`(异步处理数据)
- `mutations`(唯一能修改state的操作)
- `getters`(从state中动态获取相关数据)
- `modules`(模块化)

### actions和mutations区别

1. `actions`可以异步，`mutations`必须同步
2. `mutations`是唯一可以修改`state`的方法（`commit`）
3. `actions`修改`state`需要经过`mutations`(dispatch)

### Vuex 页面刷新数据丢失怎么解决

需要做 vuex **数据持久化**，一般使用本地储存的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件。
推荐使用 vuex-persist插件，它是为 Vuex 持久化储存而生的一个插件。不需要手动存取 storage，而是直接将状态保存至 cookie 或者 localStorage中。

### Vuex 为什么要分模块并且加命名空间

**模块**：为了防止store变得过于臃肿

 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能会变得相当**臃肿**。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

**命名空间**： 让模块具有更高的**封装度**和**复用性**     **添加 namespaced:true** 

默认情况下，模块内部的 action、mutation、getter是注册在全局命名空间的 --- 这样使得多个模块能够对同一 mutation 或 action 做出响应。如果希望你的**模块**具有**更高的封装度和复用性**，你可以通过**添加 namespaced:true** 的方式使其成为带命名的模块。当模块被注册后，他所有 getter、action、及 mutation 都会自动根据模块注册的路径调整命名。

## 如何使用vuex

### 辅助函数

Vuex属性使用的语法糖

- mapState()
- mapGetters()
- mapMutations
- mapActions

### 原始方法

`this.$store`



## Vue 修饰符

### 事件修饰符

- stop： 阻止事件继续传播
- prevent： 阻止标签默认行为
- capture： 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理
- self： 只当在 event.target 是当前元素自身时触发处理函数
- once： 事件只会触发一次
- passive： 告诉浏览器你不想阻止事件的默认行为

### v-model 修饰符

- lazy： 通过这个修饰符，转变为在 change 事件再同步
- number： 自动将用户输入值转化为数值类型
- trim： 自动过滤用户输入的收尾空格

### 键盘事件修饰符

enter、tab、delete (捕获“删除”和“退格”键)、esc、space、up、down、left、right

### 系统修饰符

ctrl、alt、shift、meta

### 鼠标按钮修饰符

left、right、middle



## $nextTick

是`Vue`提供的一个全局`API`,是在下次`DOM`**更新循环结束**之后执行**延迟回调**，在修改数据之后立即使用`$nextTick`，可以在回调中获取更新后的`DOM`

Vue在更新DOM时是异步执行的。只要侦听到数据变化，`Vue`将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个`watcher`被多次触发，只会被推入到队列中。这种在缓冲时去除重复数据对于避免不必要的计算和`DOM`操作非常重要。

`nextTick`方法会在队列中加入一个**回调**函数，确保该函数在**前面的dom操作完成后**才**调用**

**应用场景**：需要在**视图更新**之后，基于**新的视图**进行操作

## 自定义指令

指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素添加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法

**生命周期**（钩子函数）：

1、bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。

2、inserted：被绑定元素插入父节点时调用。

3、update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较前后的绑定值。

4、componentUpdated：被绑定元素所在模板完成一次更新周期时调用。

5、unbind：只调用一次，指令与元素解绑时调用。

**钩子函数参数**

- `el`：指令所绑定的元素，可以用来直接操作 DOM。
- binding：一个对象，包含以下 属性：
  - `name`：指令名，不包括 `v-` 前缀。
  - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
  - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。
- `vnode`：Vue 编译生成的虚拟节点
- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用

**原理：**
 1、在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性
 2、通过 genDirectives 生成指令代码
 3、在 patch 前将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子。
 4、当执行指令对应钩子函数时，调用对应指令定义方法。

### 如何注册自定义指令

1. 使用Vue.directive注册一个全局自定义指令
2. 钩子函数中写下指令的具体内容
3. 在元素标签中使用



## vue-router 中常用路由模式

- **hash** **模式**

1、location.hash 的值实际就是 URL 中 # 后面的东西。它的特点在于：hash虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

2、可以为 hash 的改变添加监听事件
 `window.addEventListener("hashchange",funcRef,false)`
 每一次改变 hash (window.location.hash)，都会在浏览器的访问历史中增加一个记录，利用hash的以上特点，就可以实现前端路由“更新视图但不重新请求页面”的功能了
 **特点**：兼容性好但不美观，不会被包含在 HTTP 请求中，对后端完全没有影响

- **history** **模式**

利用 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础上，他们提供了对历史记录进行修改的功能。这两个方法有个共同点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页面应用前端路由“更新视图但不重新请求页面”提供了基础

**特点**：虽然美观，但是刷新会出现 404， 需要后端进行配置。

- **abstract** 

支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式

## Vue导航守卫

- 全局的路由钩子函数：`beforeEach`、`afterEach`(一般用于全局进行权限跳转)
  - `beforeEach`:每一个路由改变之后、页面加载之前执行，三个参数（to：将要进入的路由对象、from：即将离开的路由对象、next：跳转方法）next必须调用。
  - `afterEach`每一次路由改变之后、页面加载之后执行；
- 单个路由钩子函数：`beforeEnter`、`beforeLeave`(路由内部钩子，一般在路由表里)
  - `beforeEnter`:进入指定路由跳转时需要执行的逻辑
  - `beforeLeave`:离开指定路由跳转时需要执行的逻辑
- 组件内的路由钩子函数：`beforeRouterEnter`、`beforeRouteLeave`、`beforeRouteUpdate`

## Vue函数式组件

与普通组件的**区别**：

1. 函数式组件需要在声明组件是指定 functional
2. 不需要实例化，所以没有``this``,``this``通过render函数的第二个参数来代替
3. 没有生命周期钩子函数，不能使用计算属性，watch
4. 不能通过$emit 对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件
5. 因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement
6. 函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)

**优点**：

1. 由于函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件
2. 函数式组件结构比较简单，代码结构更清晰



## Vue SSR

SSR ：服务端渲染

Vue SSR：将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。

**优点：**
 SSR 有着更好的 SEO、并且首屏加载速度更快。
**缺点：**
 开发条件会受限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。   服务器会有更大的负载需求

## 虚拟Dom

根据真实dom在内存中生成的一个js对象

产生原因：频繁操作DOM，会产生一定性能问题

## diff算法

调用patch，将虚拟dom和真实dom进行对比，如果发现不一样，就会按照依赖关系进行更新组件，而不会更新所有的组件

## Vue 模板编译原理

Vue 的编译过程就是将 template 转化为 render 函数的过程，分为以下三步：

1. 将 模板字符串 转换成 element ASTs（解析器）
2.  对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）
3.  使用element ASTs 生成 render 函数代码字符串（代码生成器）

## Vue单向数据流

​		在Vue中，父组件可以通过props 向子组件进行传值，当父组件的数据发生改变时，父级的更新会向下流动到子级，子组件中的数据会同步更新。但是，反过来则不行，也就是子组件中不能通过修改props 来更新父级的数据。

​		因此，单向数据流指的就是父级数据修改流向子级，子级不能修改父级的数据

如果要改变父组件的 props 值，可以在data里面定义一个变量，并用 props 的值初始化它，之后用$emit 通知父组件去修改。

## 为什么data是一个函数

组件的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。  每一个实例的data属性都是独立的，不会相互影响

而单纯地写成对象形式，就使得所有组件实例共用了一份data，就会造成一个一变全都变的结果

## v-if 和 v-for 为什么不能一起使用

v-for比v-if优先级高，两者同时使用，每次v-for都会执行v-if,造成不必要的计算，影响性能

## v-for的key值作用

key 是为Vue中**虚拟 DOM**的唯一标识，通过这个key，diff操作可以更**准确**、更**快速**。
 更准确：在对比中可以避免就地复用的情况，所以更加准确。
 更快速：利用key的唯一性生成map对象来获取对应节点，比遍历方式快

## Vue3.0 和 2.0 的响应式原理区别

Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达13种拦截方法

**Proxy 的优势:**

- Proxy 可以直接监听对象而非属性；
- Proxy 可以直接监听数组的变化；
- Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
- Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

**Object.defineProperty 的优势:**

兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

## MVVM

MVVM：Model–View–ViewModel

（1）View 层

View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。

（2）Model 层

Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。

（3）ViewModel 层

ViewModel 是由前端开发人员组织生成和维护的视图数据层。

- MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上
- MVVM另一个重要特性是双向绑定，它更方便去同时维护页面上都依赖于某个字段的N个区域，而不用手动更新它们

## MVC

view视图层、controller控制层、model数据层

- 各部分之间的通信都是单向
- View 传送指令到 Controller，Controller 完成业务逻辑后，要求 Model 改变状态，Model 将新的数据发送到 View，用户得到反馈
- MVC模型关注的是Model的不变，所以在MVC模型里，Model不依赖于View，但是 View是依赖于Model的

## SFC

单页面组件



# *React

## 生命周期

### 挂载阶段

- constructor()

- static getDerivedStateFromProps()

  替换：componentWillMount()

- render()      渲染真实DOM节点

- componentDidMount()

### 更新阶段

- static getDerivedStateFromProps()：从props中获取state

  替换：componentWillReceiveProps()

- shouldComponentUpdate()

- render()

- getSnapshotBeforeUpdate()

  替换：componentWillUpdate()

- componentDidUpdate()

### 卸载阶段

componentWillUnmount()

### 错误处理

当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：

- static getDerivedStateFromError()
- componentDidCatch()



## React中写方法

1. 箭头函数

   通过箭头函数让this指向组件

2. 普通函数中：用bind改变this指向

   - 通过bind绑定this

     ```
     <h1 onClick={this.click.bind(this)}>点击事件</h1>
     ```

   - bind还可以在construcotr绑定this到函数中

     ```
     constructor() {
         super();
         this.click=this.click.bind(this);
     }
     
     render() {
         return (
           <div>
             <h1 onClick={this.click}>点击事件</h1>
           </div>
         );
       }
     ```

     

## 哪个生命周期可以优化性能

1. 重写`shouldComponentUpdate`用来判断是否需要调用`render`方法重新描绘dom
2. 因为dom的描绘非常消耗性能，如果我们能在``shouldComponentUpdate``方法中能够写出更优化的`dom diff`算法，可以极大的提高性能。有时候组件的`render`函数会在没必要的情况下被调用，以此导致不必要的组价渲染

```
shuoldComponentUpdate(nextProps, nextState) {
    if (nextProps === this.props && nextState === this.state) {
        return flase;
    }
    return true;
}

// 可以使用react提供的组件PureComponent达到相同的目的。
class App exntends React.PureCompoennt {}
```

## hook函数

- useState：让函数式组件拥有状态
- useEffect：模拟生命周期
- useRef：获取dom元素
- useMemo：实现计算属性
- useCallback：缓存函数

## *useEffect函数如何模拟生命周期

可以接收两个参数：

- 第一个参数是回调函数，这个函数称为**effect**函数，主要是处理你的业务逻辑

  - 第一个参数返回的是一个清理函数，不能返回promise对象，不能直接使用async/await

  - 在回调参数中使用async/await：

    1. 使用自执行函数(立即执行函数)

       ```
       useEffect(()=>{
       	// 使用自执行函数 IIFE
       	（async function fn(){
       		await otherFn();
       	})()
       },[])
       ```

    2. 回调参数内部定义一个async函数

       ```
       useEffect(()=>{
       	const fn=async ()=>{
       		// do something
       		await otherFn()
       	}
       	fn()
       },[])
       ```

    3. 在useEffect外部定义async函数，在回调参数中去执行

       ```
       const fn=async ()=>{
       	// do something
       	await otherFn()
       }
       useEffect(()=>{
       	fn()
       },[])
       ```

- 第二个参数是一个数组：数组里面可以填写你要监控的对象

1. 模拟componentDidMount

   第二个参数是一个空数组，所以它只在初始化的时候执行一次，后面就不执行

2. 模拟componentDidUpdate

   - 不放第二个参数
   - 放第二个参数：监听这个属性

3. 模拟componentWillUnMount

   要在**effect**函数里面返回一个函数，在这个返回函数里面就可以去做一些资源清理工作

## useCallback与useMemo的区别

- `useMemo` ：计算结果是 `return` 回来的值, 主要用于 缓存计算结果的值 

  应用场景： 需要计算的状态

- `useCallback` ：计算结果是 `函数`, 主要用于 缓存函数

  应用场景: 需要缓存的函数

  函数式组件每次任何一个 state 的变化，整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费

## Redux

Redux是js应用的 一种可预测的状态容器

### 三大原则

1. 唯一数据源：整个应用的state都被存储到一个状态树里面，并且这个状态树，只存在于唯一的store中
2. 保持只读状态：state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象
3. 数据改变只能通过纯函数来执行

### redux工作流程

- `Store`:保存数据的容器

- `state`：store里存储的数据 （store里面可以拥有多个state）

  Redux规定一个state对应一个View,只要state相同，view就是一样的

- `Action`:`State`的变化，会导致`View`的变化；但是，用户接触不到`State`，只能接触到`View`；所以，`State`的变化是`View`导致的；`Action`就是`View`发出的通知 ，表示`State`应该要发生变化了

  Action是一个对象，其中，type属性是必须的，表示Action的名称，其他的可以根据需求自由设置

- `Action Creator`（动作创建器）:View要发送多少种消息，就会有多少种Action

- `dispatch`:是View发出Action的唯一方法

  接收一个Action作为参数，将它发送给store，通知store来改变state

- `Reducer`:Store收到Action以后 ，必须给出一个新的State,这样View才会发生变化。这种State的计算过程就叫做Rducer

  Rducer是一个纯函数，它接受Action和当前State作为参数，返回一个新的State

  （Reducer必须是一个纯函数，也就是说函数返回的结果必须由参数state和action决定，而且不产生任何副作用也不能修改state和action对象）

## React组件怎么获取redux里的数据

用高阶组件`Connect`建立组件与redux的连接，`Connect`的第一个参数是mapStateToProps，将redux的数据映射到组件props中

## React组件如何更新redux里的数据

dispatch派发action，通知reducer同步更新state数据



## *函数式组件和类组件的区别

1. 语法上的区别

   - 函数式组件是一个纯函数，它是需要接受props参数并且返回一个React元素就可以了
   - 类组件是需要继承React.Component的，而且class组件需要创建render并且返回React元素，语法上更复杂

2. 调用方式

   - 函数式组件可以直接调用，返回一个新的React元素
   - 类组件在调用时需要创建一个实例，然后通过调用实例里的render方法来返回一个React元素

3. 状态管理

   函数式组件没有状态管理，类组件有状态管理

4. 使用场景

   - 函数式组件一般是用在大型项目中来分割大组件（函数式组件不用创建实例，所有更高效）
   - 一般情况下能用函数式组件就不用类组件，提升效率

## 有状态组件与无状态组件

- **无状态组件**（也可以叫做展示组件）：主要用来定义模板，接收来自父组件props传递过来的数据，使用{props.xxx}的表达式把props塞到模板里面

  无状态组件应该保持模板的**纯粹性**，以便于组件**复用**

- **有状态组件**（也可以叫做容器组件）：主要用来定义**交互逻辑**和**业务数据**（如果用了Redux，可以把业务数据抽离出去统一管理），使用{this.state.xxx}的表达式把业务数据挂载到有状态组件的实例上，然后传递props到无状态组件，无状态组件接收到props，把props塞到模板里面

## 受控组件与非受控组件

- **受控组件**

  在HTML中，标签<input>、<textarea>、<select>的值的改变通常是根据用户输入进行更新。在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为：“受控组件”

  具体操作：

  1. 需给单绑定`onChange`事件
  2. 通过e.target.value获取绑定表单的值

- **非受控组件**

  表单数据由DOM本身处理。即`不受setState()`的控制，与传统的HTML表单输入相似，input输入值即显示最新值（使用 `ref`从DOM获取表单值）

  方法：

  1. 给元素绑定ref字符串（不推荐使用）
  2. 给ref绑定函数获取到原生DOM元素
  3. 通过react提供的createRef函数绑定ref

## 虚拟Dom

根据真实dom在内存中生成的一个js对象

## diff算法

自上而下使虚拟dom和真实dom进行对比，对比到哪里不一样，就从哪里开始更新所有组件

## *高阶组件与高阶函数

**高阶组件**

高阶组件是一个**函数**,并不是组件

- 以组件作为参数
- 返回值是一个组件

**withRouter**、**connect**

**高阶函数**：至少满足下列一个条件的函数，不需要都满足

- 以函数作为参数
- 返回值是一个函数

**map**、**reduce**、**filter**、**sort**、**forEach**、**every**、**some**、**includes**、**find**

## *React 什么时候重新渲染

每当**组件状态**改变时，React 都会调度渲染

## react性能优化

1. 传参优化：在传递大量数据到子组件的时候，可以使用对象传递数据

   具体做法：state中定义对象→render中用const保存该对象→组件传参

2. **key值定义**：在遍历渲染的时候要求对每个遍历后的节点都需要加上一个唯一的key

3. 分片打包

   **路由组件的懒加载**：

   - `loadable`插件可以实现组价的懒加载，第三方插件
   - `React.lazy()`也可以实现组件的懒加载，官方提供

4. **Fragment**

   在写DOM元素的时候，有时候必须在外层包裹一层组件的时候，可以使用`<></>`或者是`<React.Fragment></React.Fragment>`空标签包裹

5. 组件的卸载和加载

   针对频繁切换是否展示的组件，可以通过样式css的`display:none`属性去控制

   如果组价不是频繁的切换是否展示，可以用`true ?<User/>:null`三元的方式去写

6. **计算缓存**

   当计算量大，比较耗时的时候，可以将这个计算结果进行缓存

   - 函数组件里面可以使用`useMemo`来对**结果**缓存
   - 函数组件还可以使用`useCallback`来对**函数**进行缓存

7. **其他性能优化**

   - 组件化：达到代码可复用的目的
   - 减少DOM 操作
   - 尽量减少http请求
   - 使用雪碧图，或者精灵图将小图片存放在一个大的图片里面，通过css样式定位的方式去展示相应的图标



# Uni-app

## 生命周期

### 应用生命周期

- onLaunch：初始化完成时触发（全局只触发一次）
- onShow：`uni-app` 启动，或从后台进入前台显示
- onHide：`uni-app` 从前台进入后台
- onError：`uni-app` 报错时触发
- onUniNViewMessage：对`nvue` （uni-app 的一种渲染方式）页面发送的数据进行监听
- onUnhandledRejection：对未处理的 Promise 拒绝事件监听函数 （版本：2.8.1+）
- onPageNotFound：页面不存在监听函数
- onThemeChange：监听系统主题变化

### 页面生命周期

- onInit：监听页面初始化，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad
- onLoad：监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参）
- onShow：监听页面显示。页面每次出现在屏幕上都触发
- onReady：监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发
- onHide：监听页面隐藏
- onUnload：监听页面卸载
- onResize：监听窗口尺寸变化
- onPullDownRefresh：监听用户下拉动作，一般用于下拉刷新
- onReachBottom：页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据
- onShareAppMessage：用户点击右上角分享
- onPageScroll：监听页面滚动，参数为Object
- onBackPress：监听页面返回

### 组件生命周期

与vue标准组件的生命周期相同



## px和rpx转换

设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx

**页面元素宽度**

750 * 元素在设计稿中的宽度 / 设计稿基准宽度

## 前端适配刘海屏

1. 加上这个属性：`viewport-fit=cover`

2. 加上以下代码：

   ```
   <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
   ```

   

# git

- git clone：克隆仓库
- git add：添加到暂存区
- git commit：存到本地仓库
- git push：推送到远程仓库
- git checkout：切换分支
- git merge：合并分支



# *Webpack

## 配置

- 入口：entry --  配置js的模块名和对应的地址
- 出口：output --  配置js打包之后的路径
- 模式：mode 
  - development：开发模式  --  打包之后结构不会发生改变
  - production：生产模式  --  打包之后的所有代码都会被压缩（用于测试）

- module：配置scss、图片、内部css
- plugins：配置页面和外部css

- loader：让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）

  loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后就可以利用 webpack 的打包能力，对它们进行处理

  **常用loader**

  - babel：es6转成es5
  - css-loader
  - less-loader
  - url-loader：处理图片

- plugins：webpack插件(自动打开浏览器、热更新等)

  - HtmlWebpackPlugin：自动打开浏览器
  - Hot Module Replacement：热更新

## webpack-dev-server

一个小型的node.js Express服务器（静态文件服务器），能够用于快速开发应用程序

在`devServer`中配置：

- `open: true`  开服之后自动打开页面
- `hot: true `  热更新

## 解决跨域

`devServer`中，通过`proxy`设置跨域地址

## 启动指令

npx webpack serve

## 使用原因

保留了单个模块的可维护性，减少了页面的http请求，减少了页面加载时间，从而增加了页面的显示速度，让整个应用的体验更好

① 模块化开发（import，require）
 ② 预处理（Less，Sass，ES6，TypeScript……）
 ③ 主流框架脚手架支持（Vue，React，Angular）
 ④ 庞大的社区（资源丰富，降低学习成本）

## Webpack性能调优

自动化构建工具

1. 提高构建速度
   - 缩小文件搜索范围
   - 缓存之前构建过的js
   - 提前构建第三方库
   - 并行构建而不是同步构建
   - HMR模块热替换
2. 压缩打包体积
   - 删除冗余代码
   - 压缩代码
   - 代码分割，实现按需加载
   - Scope Hoisting
3. 优化运行速度
   - 资源文件缓存
   - 预加载
4. 优化开发体验
   - Dev-Server自动刷新
   - sourceMap提高调试体验

# 数组API

## push()

**追加**到末尾，会改变原数组

返回值：Number类型，描述数组新长度

## unshift()  

**追加**到头部，会改变原数组

返回值：Number类型，描述数组新长度

## shift() 

**删除**头部，会改变原数组

返回值：any类型，删除的元素

## pop() 

**删除**尾部，会改变原数组

返回值：any类型，删除的元素

## join()

根据分隔符转成string，不会改变原数组

```
 var arr = ['aa', 'bb', 'cc'];
    var s1 = arr.join("-");		返回：aa-bb-cc 
    var s2 = arr.join('');		返回：aabbcc
    var s3 = arr.join();		返回：aa,bb,cc
```

## reverse()

数组的反转，会改变原数组

## slice() 

截取，不会改变原数组

语法: arr.slice(beginIndex,endIndex);      包前不包后

## splice()  

更新，会改变原数组

- 删除

  语法：数组.splice(删除的元素下标,连续删除的元素个数)

- 在指定位置插入数据

  语法：数组.splice(插入的位置,0,插入的数据)		插入的位置为最后插进去后的位置

- 替换

  语法：数组.splice(替换的数据位置,要删除的长度,替换的数据)    从哪里到哪里替换


## indexOf() 和lastIndexOf ()

根据内容查找下标  （严格查找)

返回下标，如果未找到，则返回-1

```
  console.log(arr.indexOf('ab')); 		//找第一个满足
  console.log(arr.lastIndexOf("ab")); 	//找最后一个满足
  console.log(arr.indexOf(NaN)); //-1 
```

## includes()

是否包含，返回Boolean值  （不严格查找)

```
console.log(arr.includes(NaN)); //TRUE  
//NaN是js中唯一一个不等于自身的值
```

## some()

判断是否满足，最终返回true或false(一真为真)

```
var arr = [1, 8, 0];
    console.log(arr.some(item => {
        return item >= 10
    }));
```

## every()

判断是否满足，最终返回true或false(一假为假)

## reduce

```
数组.reduce(function(item,next){},初始值)	ES5
数组.reduce((item,next)=>{return...},初始值)		ES6

例：arr.reduce((item,next)=>{return item+next.price*next.num},0)	

遍历该数组，从初始值开始做累计
每次循环都会把return的值赋给item
item：上一次循环的累计值
next：每一个元素
```

## sort()

排序，会改变原数组

```
arr.sort((a, b) => {
        return a - b//升序
        return b-a//降序
    });
```



# 字符串API

都不会改变原字符串

## slice（start,end）

截取  (包前不包后)

## split()

转数组

- 字符串.split('分隔符')
- 字符串.split('分隔符',limit)

limit代表整数，作用：提取前n个

## substr(开始下标,截取长度)

如果不传截取长度，默认截取到末尾

## substring(开始下标，结束下标) 

包前不包后

如果不传结束下标，默认截取到末尾

## replace('旧内容','新内容')

只能替换第一个

