## 前端面试题

### HTML

#### HTML5的语义化标签有哪些

#### HTML5浏览器端存贮有哪些，有什么区别



### CSS

#### 什么是盒子模型

#### 标准盒子和怪异盒子，如何设置

#### CSS中的单位有哪些

#### position属性

#### 请实现一个效果，网页中有一个搜索框，当页面网上滚动，搜索框到达顶部后固定在顶部，网页滚动回来后，搜索框又回到原来的位置，您怎么实现

#### 什么是flex弹性布局

#### CSS3动画是什么

#### 请实现一个效果，一个小圆变大后又变小，一直重复

#### CSS中的伪类和伪元素

#### 鼠标以上去改变div颜色，移开后又变回原来的颜色



####  CSS权重计算

- 第一等级：代表内联样式，如style=""，权值为 1000
- 第二等级：代表id选择器，如#content，权值为100
- 第三等级：代表类，伪类和属性选择器，如.content，权值为10
- 第四等级：代表标签选择器和伪元素选择器，如div p，权值为1

> 注意：通用选择器（*），子选择器（>），和相邻同胞选择器（+）并不在这个等级中，所以他们的权值为0



### JS

#### 在原生JS中有哪些方式获取DOM元素

#### “==”与“===”的区别

#### 深拷贝与浅拷贝的区别

#### setTimeout与setInterval的区别

#### JSONP的原理

<https://www.zhihu.com/question/19966531>

#### 什么是瀑布流，以及如何判断浏览器是否触底

参考：<https://www.cnblogs.com/winyh/p/6715010.html>

document.body.clientHeigth + document.body.scrollTop===document.body.scrollHeight



#### 什么是跨域

<https://blog.csdn.net/qq_38128179/article/details/84956552>

#### JS中new的原理，请手动实现

```js
function New(Fn) {
    let obj = {};
    let args = Array.prototype.slice.call(obj, arguments);
    obj.__proto__ = Fn.prototype;
    obj.__proto__.constructor = Fn;
    let ret = Fn.apply(obj, args);
    retyrn typeof ret === 'object' ? ret || obj : obj;
}
```



#### ES6新特性

#### let,const,var的区别

#### 箭头函数与普通函数区别

#### 什么是class类

#### class类的继承

#### class类的底层原理

#### 什么是promise

#### 什么是generator

#### 防抖节流

#### 事件委托机制

#### this指向

#### 闭包

#### JS事件循环机制



### VUE

#### VUE生命周期

#### 刚进入组件时，可以在哪个生命周期里面获取DOM元素

#### v-show和v-if的区别

#### v-for和v-if在同一个标签使用会怎么样

#### this.$nextTick()有什么作用

#### 给数组增加值你怎么做（$set）

#### VUEX是什么，有哪些属性

#### VUEX中哪个属性可以发送异步请求

#### 在VUE中如何更改VUEX中的state值

#### 在VUE中如何获取VUEX中的数据

#### 什么是虚拟DOM

#### 什么是diff算法



### REACT

#### 生命周期

#### 刚进入组件时，可以在哪个生命周期里面获取DOM元素

#### REDUX是什么，有哪些属性

#### REDUX中哪个属性可以发送异步请求

#### 在react中如何更改REDUX中的state值

#### 在react中如何获取REDUX中的数据

#### react中有哪些hooks函数

#### useEffect是怎样模拟类组件的生命周期的

#### 哪个hooks函数相当于计算属性

#### useCallback与useMemo的区别

#### useCallback是如何提升性能的

#### 什么是虚拟DOM

#### 什么是diff算法



### UNIAPP

#### 应用生命周期和页面生命周期有哪些

#### rpx和px的区别



### 应用题

#### 数组对象分组

写一个函数，根据`cateId`将如下代码进行分组

```js
// 数组
const objList = [{
  name: 'a',
  cateId: 1,
},{
  name: 'b',
  cateId: 2,
},{
  name: 'b',
  cateId: 1,
}]

// 函数
group(objList, 'cateId');
// 输出
const newList = [
    [
        {
            name: 'a',
            cateId: 1
        },
        {
            name: 'b',
            cateId: 1
        }
    ],
    [
        {
            name: 'b',
            cateId: '2'
        }
    ]
]
```

答案：

```js
function group(list, key) {
    let keyArr = []; // 保存你的key的值
    let result = []; // 最终结果值
    list.forEach((item, index) => {
        const val = item[key];
        const fnIndex = keyArr.indexOf(val);
        if (fnIndex !== -1) {
            result[fnIndex].push(item);
        } else {
            keyArr.push(val);
            let resultLen = result.length;
            result[resultLen] = [];
            result[resultLen].push(item);
        }
    });
    return result;
}
```



### 请实现一个函数simplepolller，它做以下事情: 

simplePoller函数接受两个参数:queryFn和callback 
queryFn是一个返回true或false的函数 
callback是一个应该在queryFn返回true时调用的函数 
simplePoller应该定期调用queryFn 
当queryFn返回false时，它等待一段时间并再次调用queryFn，直到queryFn返回true 
queryFn调用之间的等待间隔每次增加1.5倍，从1秒开始 
当queryFn返回true时，调用callback并退出函数 
例如: 

第一次:等待1秒 
第二次:调用queryFn，它返回false，等待1.5秒 
第三次:调用queryFn，返回false，等待2.25秒 
第四次:调用queryFn，它返回true，执行回调并退出



```js
let id = 0;

const simplePoller = (function () {
  let time = 1000;
  let step = 1.5;
  let timer = null;
  return function simplePoller(queryFn, callback) {
    timer = setTimeout(() => {
      const bl = queryFn();
      if (bl) {
        callback();
        clearTimeout(timer);
        timer = null;
      } else {
        time = time * step;
        console.log(time);
        simplePoller(queryFn, callback);
      }
    }, time);
  };
})();

simplePoller(
  function () {
    id++;
    return id >= 4;
  },
  function () {
    console.log('callback成功');
  },
);

```

