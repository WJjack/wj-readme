## 前端面试题

### HTML

#### 如何理解HTML5语义化标签

利于SEO，方便阅读和维护



#### HTML5的语义化标签有哪些

```
<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。
<nav>：标记导航，仅对文档中重要的链接群使用。
<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。
<article>：定义外部的内容，其中的内容独立于文档的其余部分。
<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。
<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。
<footer>：页脚，只有当父级是body时，才是整个页面的页脚。
<audio>
<video>
...
```



#### HTML中的块元素和行级元素有哪些

> 块级元素：div、p、ul、li、h1等
>
> 行级元素：span、a、b、strong、i等



#### HTML5浏览器端存贮有哪些，有什么区别

> localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。
>
> sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。
>
> cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好



#### 在一个浏览器里面打开两个网页A和B，两个网页渲染的是同一个项目相同的地址，请问，操作A网页的localStorage能否影响B网页的localStorage数据

参考地址：https://zoyi14.smartapps.cn/pages/note/index?slug=7f9cd0111239&origin=share&_swebfr=1&_swebFromHost=vivobrowser

cookie参考：https://blog.csdn.net/weixin_43002640/article/details/115187101

> 答：能，因为在一个浏览器中相同的协议、域名和端口号下可以共享localStorage数据
>
> 但是在同一个浏览器下两个窗口即使地址相同的网页也不能共享sessionStorage数据
>
> 而cookie在同一个浏览器下两个窗口使用相同地址的同源页面可以共享数据



#### 输入网址到网页显示的过程

详见地址：https://blog.csdn.net/u014527697/article/details/79340386

1) 在客户端浏览器中输入网址URL。

2) 发送到DNS(域名服务器)获得域名对应的WEB服务器的IP地址。

3) 客户端浏览器与WEB服务器建立TCP(传输控制协议)连接。

4) 客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求。

5) WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。

6) 客户端浏览器下载数据，解析HTML源文件，解析的过程中实现对页面的排版，解析完成后，在浏览器中显示基础的页面。

7) 分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。



简单版：

1. ##### 浏览器查找该域名的IP地址

2. ##### 浏览器根据IP向web服务器发送一个http请求

3. ##### 服务器收到请求并进行处理

4. ##### 服务器返回一个响应

5. ##### 浏览器对该相应进行解码，渲染显示

6. ##### 页面显示完成后，浏览器发送异步请求



#### 什么是重绘，什么是回流（重排）？

回流（重排）：在渲染树中的一部分（或者全部）因为元素的规模尺寸、布局 、显隐等改变而需要重新构建，这就称为回流。

重绘：在渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，不影响布局，就称为重绘。



#### 何时发生回流（重排）?

-   添加或者删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边距、边框大小、高度和宽度等）
- 内容发生变化，文本或者图片被另一个不同尺寸的图片所代替
- 页面开始渲染的时候
- 浏览器的窗口尺寸变化（回流是根据视口的大小来计算元素的位置和大小的）



#### 什么时候发生重绘？

- 背景色改变
- 样式发生改变的时候



#### http常见状态码？

参考地址：https://product.pconline.com.cn/itbk/software/llq/1508/6862518.html

200：成功返回

304：从缓存中读取返回

401：权限问题

404：路劲不存在

500：服务器错误



#### 浏览器缓存

参考地址：https://blog.csdn.net/hhthwx/article/details/80152728

参考地址：https://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html

浏览器缓存就是把一个已经请求过的web资源（如html页面，图片，JS，数据）拷贝一份放在浏览器中。



**强缓存：**
用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。
**协商缓存：**
用户发送请求，发送到服务器之后，由服务器判定是否从缓存中获取资源。
**两者共同点：**客户端获取的数据最后都是熊客户端的缓存中取得。
**两者区别：**从名字就可以看出，强缓存不与服务器发生交互，而协商缓存则需要需服务器发生交互。



**优点：**

（1）减少网络带宽消耗
当web缓存副本被使用时，只会产生极小的网络流量，可以有效降低运营成本。
（2）降低服务器压力
给网络资源设定有效期之后，用户可以重复使用本地缓存，减少对源服务器的请求，简介降低了对服务器的压力，同时搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器压力。
（3）减少网络延迟
缓存的使用可以明显加快页面打开速度，达到更好的用户体验。



其他请参考上述地址



#### get请求和post请求的区别

参考地址： https://www.cnblogs.com/logsharing/p/8448446.html



#### 前端如何将img标签里的图片导出

使用canvas将img标签图片转换成base64，然后将base64转换成blob数据，使用`URL.createObjectURL()`将blob数据转换成DOMString放入到a标签的href中进行导出。

代码如下：

```js
downloadImage('图片地址'); // 导出图片


// 将base64转换成blob
function convertBase64ToBlob(base64) {
    var base64Arr = base64.split(",");
    var imgtype = "";
    var base64String = "";
    if (base64Arr.length > 1) {
        // 如果是图片base64，去掉头信息
        base64String = base64Arr[1];
        imgtype = base64Arr[0].substring(
            base64Arr[0].indexOf(":") + 1,
            base64Arr[0].indexOf(";")
        );
    }
    // 将base64解码，atob() 方法用于解码使用 base-64 编码的字符串。
    var bytes = atob(base64String);
    var bytesCode = new ArrayBuffer(bytes.length);
    // 转换为类型化数组
    var byteArray = new Uint8Array(bytesCode);
    // 将base64转换为ascii码
    for (var i = 0; i < bytes.length; i++) {
        byteArray[i] = bytes.charCodeAt(i);
    }
    // 生成Blob对象（文件对象）
    return new Blob([bytesCode], { type: imgtype });
}

// 通过canvas将img标签的数据转换成base64
function toBase64(DOMImg) {
    let canvas = document.createElement('canvas');
    canvas.width = DOMImg.naturalWidth;
    canvas.height = DOMImg.naturalHeight;

    let ctx = canvas.getContext('2d');
    ctx.drawImage(DOMImg, 0, 0, DOMImg.naturalWidth, DOMImg.naturalHeight);
    document.body.appendChild(canvas);
    let dataURL = canvas.toDataURL('image/png');
    return dataURL;
}

// 根据blob数据下载图片
function download(blob) {
    let a = document.createElement('a');
    let DOMString = URL.createObjectURL(blob);
    a.style.display = 'none';
    a.download = 'img.png';
    a.href = DOMString;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(DOMString);
    document.body.removeChild(a);
}

// 传入图片地址导出图片
function downloadImage(url) {
    let image = document.createElement('img');
    image.src = url;
    // image.setAttribute('crossorigin', 'anonymous');
    // image.setAttribute("crossOrigin",'Anonymous')
    image.onload = function() {
        // console.log(img);
        let base64 = toBase64(img);
        let blob = convertBase64ToBlob(base64);
        download(blob);
    }
}
```





### CSS

#### 什么是盒子模型

> 它具有： content，padding，border，margin 四个属性，这就是盒子模型。
>
> 盒子模型有两种形式：标准盒子模型，怪异盒子模型
>
> 两种模式可以利用box-sizing属性进行自行选择：
>
> 　　标准模式：box-sizing:content-box;
>
> 　　怪异模式：box-sizing:border-box;
>
> 两种模式的区别：
>
> 　　标准模式会被设置的padding撑开，而怪异模式则相当于将盒子的大小固定好，再将内容装入盒子。盒子的大小并不会被padding所撑开。



#### 标准盒子和怪异盒子，如何设置

> 标准模式：box-sizing:content-box;
>
> 怪异模式：box-sizing:border-box;



#### CSS中的单位有哪些

> em：它是描述相对于应用在当前元素的字体尺寸，所以它也是相对长度单位。一般浏览器字体大小默认为16px，则2em == 32px；
>
> rem：rem 是根 em（root em）的缩写，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。
>
> vw：viewpoint width，视窗宽度，1vw=视窗宽度的1%
>
> vh：viewpoint height，视窗高度，1vh=视窗高度的1%
>
> vmin：vw和vh中较小的那个。
>
> vmax：vw和vh中较大的那个。
>
> %：百分比
>
> ex：依赖于英文字母小 x 的高度
>
> ch：数字 0 的宽度
>
> px



#### position属性

> absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
>
> fixed：生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
>
> relative：生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。
>
> static：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。
>
> sticky：粘性定位，该定位基于用户滚动的位置。
>
> ​			它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。
>
> ​			**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。
>
> inherit：规定应该从父元素继承 position 属性的值。



#### 请实现一个效果，网页中有一个搜索框，当页面网上滚动，搜索框到达顶部后固定在顶部，网页滚动回来后，搜索框又回到原来的位置，您怎么实现

使用position：sticky来实现，通过定位top，left，right，bottom等控制位置

例如：

```css
.sticy {
    position: sticky;
    top: 0;
    left: 0
}
```



#### 隐藏元素的方式有哪些，以及区别

> 答：display: none、visibility: hidden、 opacity：0，定位后设置left：-10000px，top：-10000px
>
> 区别：
>
> display：none不展示元素，元素不会占据原来的位置
>
> visibility: hidden元素不可见，但是仍然占据原来的位置
>
> opacity：0：设置元素的不透明度，由于透明所以看不见，但是仍然占据原来的位置。
>
> 定位的方式设置将left和top的值设置为负的很大，以此来超出屏幕不可见。



#### 什么是flex弹性布局

参考地址：https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html



#### 水平居中的方式有哪些



#### 垂直居中



#### 什么是 BFC？

> BFC是块级格式化上下文（Block Formatting Context）的缩写，指的是一个独立的块级渲染区域，其中的元素按照特定的规则进行布局和定位。
>
> BFC最常见的表现是在容器内部的元素会垂直方向上依次排列，并且不会与外部元素重叠，同时也可以防止浮动元素对布局的影响，从而保持页面的稳定性。
>
> BFC是根据一定规则自动生成的，具体的规则包括：
>
> 1. BFC 内部的元素会按照垂直方向依次排列，且相邻元素之间不会发生重叠。
> 2. BFC 区域的左边与包含块的左边相接触，右边与包含块的右边相接触，不会超出包含块的范围。
> 3. BFC 区域中的浮动元素会参与 BFC 的计算，并影响 BFC 区域的高度。
> 4. BFC 区域不会与浮动元素重叠。
> 5. BFC 区域内部的块级元素会形成一个完整的包含块，可以包含其它块级元素。
> 6. BFC 区域内部可以通过设置 overflow 属性来控制内容的显示方式。



#### CSS3动画是什么

> 动画是让元素从一种样式逐渐变化为另一种样式的效果。
>
> 您可以改变任意多的样式任意多的次数。
>
> 请用百分比来规定变化发生的时间，或用关键词 "from" 和 "to"，等同于 0% 和 100%。
>
> 0% 是动画的开始，100% 是动画的完成。
>
> 为了得到最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。

下面的表格列出了 @keyframes 规则和所有动画属性：

![image-20211029120456576](C:\Users\jack\AppData\Roaming\Typora\typora-user-images\image-20211029120456576.png)



#### 请实现一个效果，一个小圆变大后又变小，一直重复

#### CSS中的伪类和伪元素

伪类：**用于当已有元素处于的某个状态时，为其添加对应的样式**，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。

伪元素：**用于创建一些不在文档树中的元素，并为其添加样式**。实际上，伪元素就是选取某些元素前面或后面这种普通选择器无法完成的工作。控制的内容和元素是相同的，但它本身是基于元素的抽象，并不存在于文档结构中。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。



> 常见的状态伪类主要包括：
>
> 1.  :link 应用于未被访问过的链接；   
> 2.  :hover 应用于鼠标悬停到的元素；
> 3.  :active 应用于被激活的元素；
> 4.  :visited 应用于被访问过的链接，与:link互斥。
> 5.  :focus 应用于拥有键盘输入焦点的元素。
>
> 常见的结构性伪类包括：
>
>   :first-child 选择某个元素的第一个子元素；  
>   :last-child 选择某个元素的最后一个子元素；
>   :nth-child() 选择某个元素的一个或多个特定的子元素；
>   :nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；
>   :nth-of-type() 选择指定的元素；
>   :nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；
>   :first-of-type 选择一个上级元素下的第一个同类子元素；
>   :last-of-type 选择一个上级元素的最后一个同类子元素；
>   :only-child 选择的元素是它的父元素的唯一一个子元素；
>   :only-of-type 选择一个元素是它的上级元素的唯一一个相同类型的子元素；
>   :empty 选择的元素里面没有任何内容。
>   :checked匹配被选中的input元素，这个input元素包括radio和checkbox。
>   :default匹配默认选中的元素，例如：提交按钮总是表单的默认按钮。
>   :disabled匹配禁用的表单元素。
>   :enabled匹配没有设置disabled属性的表单元素。
>   :valid匹配条件验证正确的表单元素。



> 常见伪元素：
>
>  ::first-letter 选择元素文本的第一个字（母）。
>   ::first-line 选择元素文本的第一行。
>   ::before 在元素内容的最前面添加新内容。
>   ::after 在元素内容的最后面添加新内容。
>   ::selection匹配用户被用户选中或者处于高亮状态的部分
>   ::placeholder匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效



#### 鼠标以上去改变div颜色，移开后又变回原来的颜色



#### 什么是响应式布局和自适应布局，有哪些方式可以实现？

参考地址：https://blog.csdn.net/weixin_46086607/article/details/119777458

**什么是响应式布局？**

响应式布局就是实现不同屏幕分辨率的终端上浏览网页的不同展示方式。通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验。换句话说就是一个网站能够兼容多个终端，而不是为了每一个终端做一个特定的版本。

**什么是自适应布局？**

需要开发多套界面。通过检测视口分辨率，来判断当前访问的设备是pc端、平板、手机，从而请求服务层，返回不同的页面

**区别：**

1.自适应布局通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；响应式布局通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。

2.自适应布局需要开发多套界面，而响应式布局只需要开发一套界面就可以了。

3.自适应对页面做的屏幕适配是在一定范围：比如pc端一般要大于1024像素，手机端要小于768像素。而响应式布局是一套页面全部适应。

4.自适应布局如果屏幕太小会发生内容过于拥挤。而响应式布局正是为了解决这个问题而衍生出的概念，它可以自动识别屏幕宽度并做出相应调整的网页设计。

总之，响应式布局还是要比自适应布局要好一点，但是自适应布局更加贴切实际，因为你只需要考虑几种状态就可以了而不是像响应式布局需要考虑非常多状态。所以的说无论哪种设计都有它们各自的特点，我们要根据项目的需求来选择适合的布局方式。



**响应式布局实现方式：**

1. 媒体查询

2. 百分比

3. vw/vh

4. rem

5. 利用UI框架实现响应式布局，如elementUI等

6. 移动端响应式布局viewport
   ```html
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   ```

   



####  CSS权重计算

- 第一等级：代表内联样式，如style=""，权值为 1000
- 第二等级：代表id选择器，如#content，权值为100
- 第三等级：代表类，伪类和属性选择器，如.content，权值为10
- 第四等级：代表标签选择器和伪元素选择器，如div p，权值为1

> 注意：通用选择器（*），子选择器（>），和相邻同胞选择器（+）并不在这个等级中，所以他们的权值为0



#### less或scss相比于css有什么优势？

> less和scss可以嵌套、定义变量，可以提取公共样式混入



#### 如何实现响应式布局或适配

> 1. 媒体查询
> 2. flex弹性布局
> 3. rem



### JS

#### 在原生JS中有哪些方式获取DOM元素

#### 基本数据类型有哪些？

number, string, boolean, undefined, null, Symbol

#### “==”与“===”的区别

> ==：值相等，不考虑类型
>
> ===：值和类型都要相等



#### undefined和null有什么区别

> undefined == null // true
>
> undefined === null // false
>
> 因为他们数据类型不相等，typeof undefined 数据类型是undefined ，typeof null的数据类型是object



#### 常见的判断数据类型的方式有哪些

> typeof：不能判断数组和对象
>
> * 对于基本类型，除 null 以外，均可以返回正确的结果。
> * 对于引用类型，除 function 以外，一律返回 object 类型。
> * 对于 null ，返回 object 类型。
> * 对于 function 返回 function 类型。
>
> instanceof：是用来判断 A 是否为 B 的实例
>
> Object.prototype.toString.call()



#### 你对json的理解

1. json是一种轻量级的数据交换格式，在与后端的数据交互中具有较为广泛的应用。
2. 在javaScript中，我们可以直接使用json，因为JavaScript中内置了json的解析，把任何的JavaScript对象变成json，就是把这个对象序列化成一个json格式的字符串，这样才能通过网络传递给其他计算机。如果我们收到json格式的字符串，只需要把它反序列化为一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。
3. JSON 是适用于 Ajax 应用程序的一种有效格式，原因是它使 JavaScript 对象和字符串值之间得以快速转换 JSON是一种传递对象的语法。JSON是一个提供了stringify和parse方法的内置对象。
   stringify将js对象转化为符合json标准的字符串。
   parse将符合json标准的字符串转化为js对象。



#### XMLHttpRequest如何实现终止请求？

参考地址：https://blog.csdn.net/nextstand/article/details/51163324

> 通过XMLHttpRequest对象的abort（）方法来终止请求



#### 数组的api中splice和slice的区别？

splice：可以对数组进行修改、删除添加等操作，会改变原数组

slice：对数组进行截取，返回一个新的数组，不会改变原数组



#### 什么是伪数组，如何让一个伪数组变为真数组？

> 看起来像数组，有数组的结构，但是不能用数组的方法，比如函数参数arguments就是伪数组，
>
> 通过新建一个数组，把伪数组的元素挪进去就可以变成真数组，比如[...arguments]、Array.from()。



#### eval函数的作用是什么？

参考地址：https://m.php.cn/article/421460.html

> eval()函数用于计算JavaScript字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval()函数将执行表达式。如果参数是Javascript语句，eval()将执行Javascript 语句。



#### 深拷贝与浅拷贝的区别

> 浅拷贝：是地址引用，一个对象内部值改变后会影响另一个对象内部的值
>
> 深拷贝：不是地址引用，完全生成一个新的对象，更改这个对象内部值后不影响另一个对象的内部值



#### 深拷贝JSON.stringify()的弊端

不能正确拷贝值为undefined、正则、函数等



#### 在vue中，点击table表格的修改按钮，通过=赋值的方式赋值给弹窗中的表单，当修改弹窗中表单数据后点击取消，结果table表格中的数据被点击修改的那条数据被修改到了，请问为什么，以及如何解决？



#### setTimeout与setInterval的区别

#### JSONP的原理

<https://www.zhihu.com/question/19966531>

#### 什么是瀑布流，以及如何判断浏览器是否触底

参考：<https://www.cnblogs.com/winyh/p/6715010.html>

document.body.clientHeigth + document.body.scrollTop===document.body.scrollHeight



#### 图片懒加载的方式？

参考：https://blog.csdn.net/pangji0417/article/details/123743541





#### 懒加载和预加载分别是什么？

参考：https://www.jianshu.com/p/f8e7da3a549f

参考：http://www.javashuo.com/article/p-burezcph-g.html

懒加载也叫延迟加载：js图片延迟加载，延迟加载图片或者符合某些条件是才加载某些图片；

预加载：提早加载图片，当用户须要查看时可直接从本地缓存中渲染。（base64小图片能够经过css保存）

**区别：**

两种技术的本质：二者的行为相反，一个是提早加载，一个是迟缓甚至不加载。懒加载会对前端有必定的缓解压力做用，预加载则会增长前端的压力。

懒加载的主要目的是优化前端性能，减小请求数或延迟请求数。

​          方法：

​            a、纯粹的延迟加载，使用setTimeOut或者setInterval 进行加载延迟；

​            b、条件加载，符合某些条件，或者触发了某些事件才开始异步下载；

​            c、可视区加载，即仅加载能够看到的区域，监控滚动条实现。

 预加载是牺牲前端性能，换取用户体验，使用户的操做获得最快的反映。

​          方法：

​          好比：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。



#### 什么是跨域

<https://blog.csdn.net/qq_38128179/article/details/84956552>

#### JS中new的原理，请手动实现

```js
function New(Fn) {
    let obj = {};
    let args = Array.prototype.slice.call(obj, arguments);
    obj.__proto__ = Fn.prototype;
    obj.__proto__.constructor = Fn;
    let ret = Fn.apply(obj, args);
    retyrn typeof ret === 'object' ? ret || obj : obj;
}
```



#### 简述什么是事件冒泡，如何阻止事件冒泡？

> 在一个对象上触发某类事件（比如单击 onclick 事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即 document 对象（有些浏览器是 window）
>
>  阻止事件冒泡的方法
>
>  第一种：event.stopPropagation();
>
>  第二种：return false;



#### ES6新特性

#### let,const,var的区别

> var声明变量存在变量提升，let和const不存在变量提升
>
> let、const都是块级局部变量
>
> 同一作用域下let和const不能声明同名变量，而var可以



#### 下面代码依次输出什么

```js
var a = 10;
(function () {
    console.log(a)
    a = 5
    console.log(window.a)
    var a = 20;
    console.log(a)
})()
```

> 答：依次输出：undefined -> 10 -> 20
>
> 理由：
>
> 1. `在立即执行函数中，var a = 20; 语句定义了一个局部变量 a，由于js的变量声明提升机制，局部变量a的声明会被提升至立即执行函数的函数体最上方，且由于这样的提升并不包括赋值，因此第一条打印语句会打印undefined，最后一条语句会打印20。`
> 2. `由于变量声明提升，a = 5; 这条语句执行时，局部的变量a已经声明，因此它产生的效果是对局部的变量a赋值，此时window.a 依旧是最开始赋值的10，`



#### 箭头函数与普通函数区别

箭头函数this指向外层，不能被更改，不能被实例化，没有原型，也没有arguments对象

普通函数this可以更改，可以被实例化，有原型，有arguments对象



题目如下：

```jsx
let fn1 = (a) => a;
let fn2 = (a) => {a}
let fn3 = (a) => ({a})

fn1(1);
fn2(1);
fn3(1);
```

请问，上述函数运行后分别返回什么值？

```js
fn1(1); // 1
fn2(1); // undefined
fn3(1); // {a: 1}
```



#### 数组常用api



#### 数组中哪些api执行后会改变原数组？

> pop、push、shift、unshift、splice等



#### 数组去重的方式有哪些？

第一种方式：使用Set去重（这种方式只能对基本数据去重，无法对数组对象去重）

```js
let arr = [1,2,3,3,5,5];
let arr2 = [...new Set(arr)]; // [1,2,3,5]
```

第二种方式：循环对数组对象去重（根据对象中的唯一key进行判断）

```js
let arr = [{
    id: '1',
    name: '张三'
}, {
    id: '1',
    name: '张三'
}, {
    id: '2',
    name: '李四'
}]
let result = []; // 保存去重后的数据
let obj = {}; // 保存唯一key和值
arr.forEach(item => obj[item.id] = item); 

for(let k in obj) {
    result.push(obj[k]);
}
```

其他方式可以用for循环或循环的相关api去处理。



#### 数组扁平化方式

参考地址：https://blog.csdn.net/qq_38128179/article/details/89950590

* **Array.prototype.flat()**
* **归并方法 reduce()**
* **toString()**
* **循环+递归**
* **扩展运算符. . .**



#### 什么是class类

class关键字，类名首字母大写，有`constructor`构造器，还有方法，getter和setter

继承使用extends关键字，需要在constructor中调用super实例化父类。



#### class类的继承

#### class类的底层原理

class本质就是一个函数，它也有原型和原型链。

它的getter是通过Object.defineProperty劫持原型实现的

```js
Object.defineProperty(Person.prototype, 'name', {
    get() {
        return this.username;
    }
})
Object.defineProperty(Person.prototype, 'setName', {
    set(val) {
        this.username = val;
    }
})
```



#### 什么是promise

> Promise是一个类，在原型上有方法then、catch、finally、resolve、reject等，实例化一个Promise时构造器中会执行传入的函数，这个函数中有两个参数，一个是resolve、一个是reject，then函数中会将传入的函数参数保存到一个数组中，当resolve执行时就会去循环执行这个数组中的函数。

#### Promise.all()

> Promise.all()接收一个数组作为参数，数组中的参数都是promise实例，只有当这些promise实例全部是成功状态是才会执行.then

#### Promise.race()

> Promise.race接收一个数组作为参数，数组中的参数都是promise实例，哪个实例状态先成功.then就会是谁的数据

#### Promise.allSettled()

> Promise.allSettled()接收一个数组作为参数，数组中的参数都是promise实例，及时当中有状态是失败，但仍然执行.then



#### Promise实现原理，简单介绍

> Promise是一个类，在原型上有方法then、catch、finally、resolve、reject等，实例化一个Promise时构造器中会执行传入的函数，这个函数中有两个参数，一个是resolve、一个是reject，then函数中会将传入的函数参数保存到一个数组中，当resolve执行时就会去循环执行这个数组中的函数。



#### 一个页面中等待所有请求完成或关闭loading动画，如何实现？

> Promise.all().then(() => {});在then函数中关闭动画



#### 假如在项目中，前端调用一个接口（这个接口有做分页查询）获取一万条数据需要5秒，如果让前端来优化在1秒左右查询出一万条数据，你会怎么做？

> 创建5个promise实例将这一万条数据分成5次调用接口，通过分页查询每次获取2000条，总共加起来一万条，使用promise.all将5个promise实例放入其中，等到5个接口全部调用成功后将数据拼接起来形成一万条数据。每个接口查询时间大概1秒，总共花费时间也就大概1秒。



#### Promise和async await的关系

参考地址：https://blog.csdn.net/qq_34618600/article/details/121180602

> 1. 执行async函数，返回的是Promise对象
>
> 2. await相当于Promise的then
> 3. try…catch 可捕获异常，代替了Promise的catch



#### 什么是generator

#### 防抖节流

参考地址：https://segmentfault.com/a/1190000018428170

**防抖**：

> 如果短时间内大量触发同一事件，只会在结束触发事件后延迟指定时长执行一次函数。

源码：

```js
function debounce(fn,delay){
    let timer = null //借助闭包
    return function() {
        if(timer){
            clearTimeout(timer) 
        }
        timer = setTimeout(fn,delay) // 简化写法
    }
}
```

**节流**：

> 如果用户一直触发某个事件，只会每个指定间隔时间触发一次，可多次触发。
>
> 每间隔多少毫秒就触发一次

源码：

```js
function throttle(fn,delay){
    let valid = true
    return function() {
       if(!valid){
           //休息时间 暂不接客
           return false 
       }
       // 工作时间，执行函数并且在间隔期内把状态位设为无效
        valid = false
        setTimeout(() => {
            fn()
            valid = true;
        }, delay)
    }
}
```



#### 事件委托机制

采用事件冒泡机制，将子元素的事件冒泡到父元素执行。比如动态添加子元素

见面试题md文档



#### this指向

> （1）普通函数调用，此时 this 指向全局对象，浏览器为 window，严格模式指向undefined
>
> （2）构造函数调用， 此时 this 指向 实例对象
>
> （3）对象方法调用， 此时 this 指向 该方法所属的对象
>
> （4）箭头函数指向外层
>
> （5）更改this指向，apply、call、bind
>
> 区别：
>
> * apply和call改变this指向时会立即执行，而bind不会
> * apply使用数组传递参数，而call是一个一个传递



#### 下列代码一次输出什么？

```js
var name = 'window';
var person1 = {
    name: 'person1',
    foo1: function() {
        console.log(this.name);
    },
    foo2: () => console.log(this.name),
    foo3: function() {
        return function () {
            console.log(this.name);
        }
    },
    foo4: function() {
        return () => {
            console.log(this.name);
        }
    }
}

var person2 = {
    name: 'person2'
}

person1.foo1(); // person1
person1.foo1.call(person2); // person2
person1.foo2(); // window
person1.foo2.call(person2); // window
person1.foo3()(); // window
person1.foo3.call(person2)(); // window
person1.foo3().call(person2); // person2
person1.foo4()(); // person1
person1.foo4.call(person2)(); // person2
person1.foo4().call(person2); // person1
```



#### 闭包

> 闭包的三大特点为：
>
> 1、函数嵌套函数
>
> 2、内部函数可以访问外部函数的变量
>
> 3、参数和变量不会被回收。会导致内存泄漏。



#### JS事件循环机制

事件循环过程：

1. 主线程分析全局变量、函数等等。
2. 将全局变量和函数放入全局上下文对象中，压入栈低
3. 开始从上到下执行代码，发现有函数要运行，就将它压入栈低，执行函数内部代码
4. 执行代码与JavaScript库进行对比，发现是异步请求，就交给异步请求模块进行处理，主线程继续往下执行
5. 与JavaScript库进行对比，发现同步代码就执行，继续往下执行
6. 与JavaScript库进行对比，发现是定时器，就交给定时器模块处理，继续往下执行
7. 知道最后执行完毕，主线程就会去异步任务队列询问有没有任务，有任务就执行，执行完毕又去循环，如果有就继续执行，循环这个过程，直到异步任务队列执行完毕，主线程就退出，整个代码就执行完毕了。

在异步任务队列中又分为宏任务和微任务，微任务一般先执行，宏任务后执行。

宏任务：setTimout、setInterval、IO。

微任务：promise.then、process.nextTick（node）等等



这里有一段代码，请看下，然后请说出打印顺序

```js
console.log('成都');
// 浏览器会有默认时间
setTimeout(() => {
    console.log('武汉');
}, 0);
console.log('西安');
const p = new Promise((resolve, reject) => {
    console.log('重庆');
    resolve();
})
p.then(() => {
    console.log('上海');
});
console.log('深圳');
```

打印顺序：成都、西安、重庆、深圳、上海、武汉



#### __proto和prototype的区别和联系？

> 区别：`__proto`__是隐式原型，prototype是显示原型，`__proto`是实例对象才有的的属性，而prototype只有函数才会有这个属性
>
> 联系：`__proto`指向了prototype原型，prototype的构造器`constructor`指向了函数本身



#### JS原型和原型链

**原型：**

每一个JavaScript对象（除了null）创建的时候，都会与之关联另一个对象，这对象就是我们说的原型，每个对象都会从原型中继承属性和方法。

`prototype`：函数才有prototype属性，这个属性指向函数原型对象

`__proto__`：每个对象（除了null）都有的属性，这个属性指向该对象的原型
`constructor`：每个原型都有一个constructor属性，指向关联的构造函数。

**原型链：**

简单表述：如果实例去访问属性，这个实例本身没有这个属性，就会到原型上去寻找，如果原型上没有这个歌属性，就会到原型的原型上去寻找，一直重复这个过程，知道找到并返回这个值为止，或者没有找到这个值返回undefined，原型链找不到了就null（原型链的出口就是null）。

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/wujie/20220715144627.png)

#### 函数作用域和作用域链

参考：https://www.cnblogs.com/onepixel/p/5036369.html



### VUE

#### VUE生命周期

#### 刚进入组件时，可以在哪个生命周期里面获取DOM元素

#### v-model语法糖

```js
@input 和 value
```

#### vue自定义指令

参考地址：https://cn.vuejs.org/v2/guide/custom-directive.html

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/wujie/20220721115738.png)

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/wujie/20220721115808.png)

封装一个按钮级别权限控制的自定义指令

```typescript
import Vue from "vue";

Vue.directive('permission', {
    inserted(el, binding) {
        let {value} = binding;

        let p = localStorage.getItem('permissions');
        let permissions: string[] = JSON.parse(p ?? '[]')

        if (!permissions.some(item => item === value)) {
            // 无权限则删除当前按钮
            el.remove();
        }
    }
})
```





#### v-show和v-if的区别

#### v-for和v-if在同一个标签使用会怎么样

#### watch和computed的区别

> computed是计算属性，会根据data里面的a和b数据进行计算，然后返回新的值，这个值会被缓存，如果a和b没有修改，那么不会去重新计算
>
> watch：监听属性，监听某个值，如果这个值改变则会去执行函数，这个函数里面可以做更复杂的操作，比如发起网络请求，而computed就不能。

#### vue中的data为什么是一个函数？

#### this.$nextTick()有什么作用

在dom元素更新完成后执行的回调函数。如果你要在state值更新后里面去获取最新的dom元素，就要使用它。

#### 给数组修改值你怎么做（$set）

> 通过set更改值，会引起dom元素的渲染。



#### 路由导航守卫有哪些？

> 分为三种：全局守卫、路由独享守卫、组件内守卫
>
> 全局守卫：beforeEach、afterEach
>
> 路由独享守卫：beforeEnter
>
> ```js
> const routes = [
>   {
>     path: '/users/:id',
>     component: UserDetails,
>     beforeEnter: (to, from) => {
>       // reject the navigation
>       return false
>     },
>   },
> ]
> ```
>
> 组件内守卫：`beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`
>
> ```vue
> <script>
> export default {
>   beforeRouteEnter(to, from) {
>     // 在渲染该组件的对应路由被验证前调用
>     // 不能获取组件实例 `this` ！
>     // 因为当守卫执行时，组件实例还没被创建！
>   },
>   beforeRouteUpdate(to, from) {
>     // 在当前路由改变，但是该组件被复用时调用
>     // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
>     // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
>     // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
>   },
>   beforeRouteLeave(to, from) {
>     // 在导航离开渲染该组件的对应路由时调用
>     // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
>   },
> }
> </script>
> ```



#### vue router路由跳转和location.href跳转路由有什么区别？

> 使用location.href=’/url’来跳转，简单方便，但是刷新了页面；
>
>  使用history.pushState(’/url’)，无刷新页面，静态跳转；
>
>  引进router，然后使用router.push(’/url’)来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。



#### 简单说一下vue中keep-alive的基本原理？

参考地址：https://www.jianshu.com/p/f3c52707656a

> Vue.js内部将DOM节点抽象成了一个个的[VNode节点](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fanswershuto%2FlearnVue%2Fblob%2Fmaster%2Fdocs%2FVNode%E8%8A%82%E7%82%B9.MarkDown)，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（include与exclude）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。



#### vue2中定义一个对象，有年龄、名字等属性，通过js代码添加一个性别属性（obj.gender）,页面上是否立马显示？如果不能请说出正确解决方案？

> 答：不能立马显示，因为vue2中是通过defineProperty对数据劫持，不能检测到obj.gender这样的添加属性
>
> 正确方式是使用this.$set方式去增加obj.gender



#### history和hash路由的区别，history有什么缺陷以及怎么解决？

参考地址：https://blog.csdn.net/qq_57334853/article/details/125798638

![](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/wujie/20220926194444.png)



#### VUE组件通信方式有哪些

#### VUEX是什么，有哪些属性

#### VUEX中哪个属性可以发送异步请求

#### 在VUE中如何更改VUEX中的state值

#### 在VUE中如何获取VUEX中的数据

#### vuex中的dispatch和commit有什么不同

#### vue响应式原理

**注册环节：**vue2版本采用Object.defineProperty()方法中的getter和setter劫持数据，组件初始化的时候，先给每一个Data属性都注册getter，setter，也就是reactive化。然后再new 一个自己的Watcher对象，此时watcher会立即调用组件的render函数去生成虚拟DOM。在调用render的时候，就会需要用到data的属性值，此时会触发getter函数，将当前的Watcher函数注册进sub里。每一个组件对应一个Watcher对象。

**发布环节：**一旦你执行Object.defineProperty的set方法，就会调用Dep函数里面 notifyAll方法来通知所有的watch进行工作。检测数据变化引起页面更新。



#### vue2和vue3的区别？

参考地址：https://blog.csdn.net/u014645827/article/details/125781194

> 1. 数据双向绑定的底层实现不同，vue2中使用defineProperty来对数据进行劫持，而vue3使用Proxy代理数据
> 2. 写法上的不同，vue3中更偏向于函数式编程，并有ref，reactive等函数，还有`<script setup>`的写法，编程更加自有灵活，而vue2是在对象中对每一个对象块编程，比如method、computed、data等
> 3. 与ts的结合，vue3使用ts进行开发，对ts更加友好，而vue2对ts并不那么友好
> 4. vue3的性能比vue2更高
> 5. 生命周期有部分变化，比如写法不同，vue3中以`on`开头，如`onMounted`对应vue2中`mounted`，vue3中`setup`替代了`beforeCreate`和`created`



### vue3

#### 什么情况下reactive定义的数据会失去响应性？

> 1. 解构reactive定义的数据会失去响应性
>    ```js
>    let  { nage, age } = reactive({name, age}) // 会失去响应性
>    ```
>
> 2. 直接给reactive定义的值赋值
>    ```js
>    let list = reactive([]);
>    list = [{}]  // 会失去响应性
>    ```



#### pinia核心内容



### REACT

#### 生命周期

参考地址：https://www.jianshu.com/p/b331d0e4b398

![image-20211101144943859](https://woniumd.oss-cn-hangzhou.aliyuncs.com/web/wujie/20211101145021.png)



#### 刚进入组件时，可以在哪个生命周期里面获取DOM元素

#### Purecomponent

#### 你对受控组件和非受控组件有什么区别？

> 受控组件
>
> 1. 保持着自己的状态，数据有内部状态state提供
> 2. 通过表单的事件去触发修改state数据
>
> 非受控组件：
>
> 1. Refs 用于获取其当DOM元素来获取值
> 2. 没有维持自己的状态



#### react中key值的作用

> React中的key 值必须保证其唯一和稳定性
>
> react中的key属性，它是一个特殊的属性，它是出现不是给开发者用的，而是给React自己使用，有了key属性后，就可以与组件建立了一种对应关系，react利用key来识别组件，他是一种身份标识。每个key 对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。在render函数执行的时候，新旧两个虚拟DOM会进行对比，如果两个元素有不同的key，那么在前后两次渲染中就会被认为是不同的元素，这时候旧的那个元素会被销毁，新的元素会被创建。如果提供了唯一的标识key且是相同的key，且元素类型相同， 若元素属性有所变化，则React只更新组件对应的属性，这种情况下，性能开销会相对较小。



#### react中路由懒加载的方式有哪些

> 1. 使用第三方插件react-loadable
> 2. 使用官方推荐的方式`React.Suspense`和`React.lazy`搭配完成



#### react中绑定ref的方式有哪些？

* React.createRef
* 绑定箭头函数
* useRef



#### setState异步还是同步

#### setState对象参数连续执行合并的问题

#### 如何避免setState执行合并的问题

#### setState第二个参数有什么用

#### react组件通信方式有哪些

> * 父传子组件props
> * 子通知父组件更新数据，将父组件传入的函数运行
> * eventBus：安装events插件完成订阅发布
> * redux
> * context上下文（建议少用）
> * 函数组件中useContext上下文
> * ref绑定获取组件实例
> * props.children

#### REDUX是什么，有哪些属性

#### REDUX中哪个属性可以发送异步请求

#### 在react中如何更改REDUX中的state值

#### 在react中如何获取REDUX中的数据

#### 什么是高阶组件

#### react中有哪些hooks函数

#### React Hook 的使用限制有哪些？

> - 不要在循环、条件或嵌套函数中调用 Hook；
> - 在 React 的函数组件中调用 Hook。

#### 那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？（非重点）

> 因为 Hooks 的设计是基于链表实现。在调用时按顺序加入链表中，如果使用循环、条件或嵌套函数很有可能导致链表取值错位，执行错误的 Hook。

#### useEffect是怎样模拟类组件的生命周期的

#### 哪个hooks函数相当于计算属性

#### useRef有什么作用

#### useCallback与useMemo的区别

#### useCallback是如何提升性能的

#### 什么是虚拟DOM

参考地址：https://www.jianshu.com/p/8c1505ebcf0e

#### 什么是diff算法



#### 谈谈你对MVVM框架的理解

参考地址：https://www.php.cn/faq/462461.html

MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。

在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

　　ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。



#### vue和react的区别

参考地址：https://www.zhihu.com/question/309891718/answer/1066629375

参考地址：https://www.jianshu.com/p/b7cd52868e95



> 基本：
>
> 1. Vue 使用的是 web 开发者更熟悉的模板与特性，Vue的API跟传统web开发者熟悉的模板契合度更高；React 的特色在于[函数式编程](https://www.zhihu.com/search?q=函数式编程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1066629375})的理念和丰富的技术选型。
> 2. Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。
>
> 
>
> 高级：
>
> react：
>
> react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。react在setState之后会重新走渲染的流程，如果shouldComponentUpdate返回的是true，就继续渲染，如果返回了false，就不会重新渲染，PureComponent就是重写了shouldComponentUpdate，然后在里面作了props和state的浅层对比。
>
> vue：
>
> 而vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。
>
> 总体来说：
>
> react的性能优化需要手动去做，而vue的性能优化是自动的，但是vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用react，更加可控。
>



#### v3的组合式api和react 中hook 比起来相同点和不同点

参考地址：https://blog.csdn.net/qq_37669585/article/details/126425473

区别主要有：
React hooks：

* Hooks有严格的调用顺序，不能写在条件分支中。
* React组件中定义的变量在一个钩子函数闭包中捕获，开发者非常依赖ESLint规则来保证依赖数组的传递正确性，而这些规则不够智能。
* 昂贵计算需要useMemo，并且要传入正确的依赖数组。
* React在默认情况下，传递给子组件的事件处理函数会导致子组件不必要更新，需要调用useCallback优化。避免过度渲染，引发性能问题。
* 变量闭包问题。较难推理出一段钩子代码什么时候运行，且不好处理多次渲染间的useRef的可变状态。

Vue的组合式API：

* setup走天下，不需要担心闭包变量问题，不限制调用顺序，可以有条件调用。
* Vue响应式自动收集依赖，无需手动声明依赖。
* 无需手动缓存回调函数避免不必要组件更新。（Vue的保姆式包办）



#### git常用命令有哪些？



### webpack

#### webpack 中loader的作用是什么？

> webpack中只认识js文件，所以针对其他非js文件webpack并不认识，loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。



### UNIAPP

#### 应用生命周期和页面生命周期有哪些

#### rpx和px的区别

#### 兼容处理

参考地址：https://uniapp.dcloud.io/tutorial/platform.html#preprocessor

#### 扫码功能

具体详见：https://uniapp.dcloud.net.cn/api/system/barcode.html#scancode

```js
uni.scanCode
```

#### 小程序分包有什么作用

参考：https://uniapp.dcloud.net.cn/collocation/pages.html#subpackages

> 因小程序有体积和资源加载限制，各家小程序平台提供了分包方式，优化小程序的下载和启动速度。
>
> 所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本
>
> 在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，会把对应分包自动下载下来，下载完成后再进行展示。此时终端界面会有等待提示。
>
> 微信小程序每个分包的大小是2M，总体积一共不能超过20M。



#### uni-app开发时，前端解决跨域问题的方式有哪些？

参考：https://www.likecs.com/show-308363167.html



### 整个前端领域的性能优化方案有哪些

* 样式引入时使用link标签，少使用@import
* 尽量减少http请求次数
* 尽量少操作dom元素，减少回流和重绘
* 小图标使用雪碧图（精灵图）
* 路由懒加载
* 图片懒加载
* 防抖节流
* 瀑布流、触底加载
* 使用在线工具压缩图片大小
* 打包生产包时压缩代码体积
* 使用tree shaking将不使用的代码踢出
* 在vue中区别使用v-show和v-if
* 合理使用计算属性computed或useMemo、useCallback
* 在vue或react中循环渲染标签时加上key属性



### 场景题

#### 项目过大的时候，首页会有白屏时间，怎么解决？

> 使用路由懒加载、打包时尽量压缩代码、压缩图片、精灵图、第三方插件的按需引入等



#### 跨域解决方式你知道哪些？

> 1. 开发阶段前端配置webpack 的devServer解决开发阶段的跨域问题，但是上线后无效
> 2. jsonp的方式，但是这种方式比较古老，现在基本不用
> 3. 后端去解决跨域问题比较好。



#### 浏览器端兼容性问题有哪些解决方案？

> js：
>
> js中es的api不能用，使用低版本api完成，比如forEach不能用，使用for循环替代，let、const不能用，只能用var等。
>
> js，可以通过babel插件或ts将代码编译成es5版本的低级代码运行
>
> css：
>
> css样式兼容性前缀，比如-webkit-、-moz-等，可以使用postcss配置自动完成前缀添加

其他的兼容性解决方案，你们可以自行百度，没有完全的标准答案。



#### 开发后台项目时，在vue和react中，页面访问权限控制分别如何做？以及按钮级别权限控制分别如何做？



#### 为什么选择使用uni-app去开发？

看uni-app官网对uni-app的介绍



#### 封装一个函数名为useToken的hook函数返回token和用户信息，数据默认存储在localstorage中



#### 封装一个函数名为useAuth的hook函数，功能是返回当前用户是否登录的布尔值。



#### 封装一个函数名为useUpdateEffect 的 hook函数，功能是第一次进入函数组件时不执行effect函数，当监听的数据改变后执行effect函数。useUpdateEffect函数的使用方式和useEffect函数是一样。useUpdateEffect(() => {}, [])



#### 封装一个函数名为useUserList的hook函数，功能是调用接口查询用户数据并返回用户数据。



#### 如果让你从0开始搭建项目，除了请求外，你还会封装哪些



### 应用题

#### 将一个数组的值全部相加并返回结果，例如：arr = [1,2,3,4,5]



#### 请实现一个名为getName的函数，返回一个数组。

输入：

```js
let data = [
    {
        id: 1, name: "集团", pid: null,
        children: [
            {
                id: 2, name: "子公司", pid: 1,
                children: [
                    { id: 3, name: "财务部门", pid: 2 }
                ]
            },
        ]
    }
]

getName(data);
```

输出返回数组值为：

```js
['集团', '子公司', '财务部门']
```





#### 请用 javascript 实现一个函数 parseSearch(url)，将一段 url字符串解析为 Object。

输入：

```js
parseSearch("?id=123456&sort=discount");
```

期望结果：

```js
{
    id: "12345",
    sort: "discount"
}
```





#### 数组对象分组

写一个函数，根据`cateId`将如下代码进行分组

```js
// 数组
const objList = [{
  name: 'a',
  cateId: 1,
},{
  name: 'b',
  cateId: 2,
},{
  name: 'b',
  cateId: 1,
}]

// 函数
group(objList, 'cateId');
// 输出
const newList = [
    [
        {
            name: 'a',
            cateId: 1
        },
        {
            name: 'b',
            cateId: 1
        }
    ],
    [
        {
            name: 'b',
            cateId: '2'
        }
    ]
]
```

答案：

```js
function group(list, key) {
    let keyArr = []; // 保存你的key的值
    let result = []; // 最终结果值
    list.forEach((item, index) => {
        const val = item[key];
        const fnIndex = keyArr.indexOf(val);
        if (fnIndex !== -1) {
            result[fnIndex].push(item);
        } else {
            keyArr.push(val);
            let resultLen = result.length;
            result[resultLen] = [];
            result[resultLen].push(item);
        }
    });
    return result;
}
```



#### 请实现一个函数simplepolller，它做以下事情: 

simplePoller函数接受两个参数:queryFn和callback 
queryFn是一个返回true或false的函数 
callback是一个应该在queryFn返回true时调用的函数 
simplePoller应该定期调用queryFn 
当queryFn返回false时，它等待一段时间并再次调用queryFn，直到queryFn返回true 
queryFn调用之间的等待间隔每次增加1.5倍，从1秒开始 
当queryFn返回true时，调用callback并退出函数 
例如: 

第一次:等待1秒 
第二次:调用queryFn，它返回false，等待1.5秒 
第三次:调用queryFn，返回false，等待2.25秒 
第四次:调用queryFn，它返回true，执行回调并退出



```js
let id = 0;

const simplePoller = (function () {
  let time = 1000;
  let step = 1.5;
  let timer = null;
  return function simplePoller(queryFn, callback) {
    timer = setTimeout(() => {
      const bl = queryFn();
      if (bl) {
        callback();
        clearTimeout(timer);
        timer = null;
      } else {
        time = time * step;
        console.log(time);
        simplePoller(queryFn, callback);
      }
    }, time);
  };
})();

simplePoller(
  function () {
    id++;
    return id >= 4;
  },
  function () {
    console.log('callback成功');
  },
);

```

